// Generated by LiveScript 1.6.0
(function () {
  var ref$,
    times,
    minus,
    plus,
    div,
    toJS,
    transaction,
    calcFee,
    find,
    round5,
    roundNumber,
    contractData,
    calcCryptoGeneric,
    calcCryptoFromUsd,
    calcCryptoFromEur,
    calcFiat,
    calcUsd,
    calcEur,
    calcFeeProxy,
    calcFeeBeforeSend,
    changeAmountGeneric,
    changeAmountSend,
    changeAmountCalcFiat,
    changeAmountWithoutFee,
    changeAmount,
    changeAmountInvoice,
    out$ = (typeof exports != 'undefined' && exports) || this;
  (ref$ = require('./math.ls')),
    (times = ref$.times),
    (minus = ref$.minus),
    (plus = ref$.plus),
    (div = ref$.div);
  (ref$ = require('mobx')),
    (toJS = ref$.toJS),
    (transaction = ref$.transaction);
  calcFee = require('./api.ls').calcFee;
  find = require('prelude-ls').find;
  round5 = require('./round5.ls');
  roundNumber = require('./round-number.ls');
  contractData = require('./contract-data.ls');
  calcCryptoGeneric = function (name) {
    return function (store, val) {
      var send, wallet, token, rate, ref$;
      if (val == null) {
        return '0';
      }
      send = store.current.send;
      wallet = send.wallet;
      token = send.coin.token;
      rate = (ref$ = wallet != null ? wallet[name] : void 8) != null ? ref$ : 0;
      return div(val, rate);
    };
  };
  out$.calcCryptoFromUsd = calcCryptoFromUsd = calcCryptoGeneric('usdRate');
  out$.calcCryptoFromEur = calcCryptoFromEur = calcCryptoGeneric('eurRate');
  calcFiat = function (name) {
    return function (store, amountSend) {
      var send, wallet, token, rate, ref$;
      if (amountSend == null) {
        return '0';
      }
      send = store.current.send;
      wallet = send.wallet;
      token = send.coin.token;
      rate = (ref$ = wallet != null ? wallet[name] : void 8) != null ? ref$ : 0;
      return times(amountSend, rate);
    };
  };
  out$.calcUsd = calcUsd = calcFiat('usdRate');
  out$.calcEur = calcEur = calcFiat('eurRate');
  calcFeeProxy = function (input, cb) {
    return calcFee(input, function (err, fee) {
      if (err != null) {
        console.error('fee err: ' + err);
      }
      if (err != null) {
        return cb(err);
      }
      return cb(null, fee);
    });
  };
  out$.calcFeeBeforeSend = calcFeeBeforeSend = function (arg$, cb) {
    var store,
      query,
      fast,
      token,
      to,
      data,
      network,
      amount,
      feeType,
      txType,
      account,
      swap,
      send,
      calcFeeFun,
      gasPrice;
    (store = arg$.store), (query = arg$.query), (fast = arg$.fast);
    (store = query.store),
      (token = query.token),
      (to = query.to),
      (data = query.data),
      (network = query.network),
      (amount = query.amount),
      (feeType = query.feeType),
      (txType = query.txType),
      (account = query.account),
      (swap = query.swap);
    if (store == null) {
      return cb('store isn`t defined');
    }
    if (network == null) {
      return cb('network isn`t defined');
    }
    if (amount == null) {
      return cb('amount isn`t defined');
    }
    if (account == null) {
      return cb('account isn`t defined');
    }
    if (token == null) {
      return cb('token isn`t defined');
    }
    send = store.current.send;
    send.feeCalculating = true;
    calcFeeFun = fast ? calcFee : calcFeeProxy;
    gasPrice = (function () {
      switch (false) {
        case (send != null ? send.gasPriceType : void 8) !== 'custom':
          return times(
            send != null ? send.gasPriceCustomAmount : void 8,
            Math.pow(10, 9)
          );
        default:
          return send.gasPriceAuto;
      }
    })();
    return calcFeeFun(
      {
        store: store,
        token: token,
        to: to,
        data: data,
        network: toJS(network),
        amount: amount,
        feeType: feeType,
        txType: txType,
        account: account,
        gasPrice: gasPrice,
        swap: swap,
      },
      function (err, result) {
        var ref$;
        send.feeCalculating = false;
        if (err != null) {
          send.error = ((ref$ = err.message) != null ? ref$ : err) + '';
        }
        if (err != null) {
          return cb(((ref$ = err.message) != null ? ref$ : err) + '');
        }
        console.log('calcFeeFun', result);
        return cb(null, result);
      }
    );
  };
  changeAmountGeneric = function (field) {
    return function (store, amountSend, fast, cb) {
      var send,
        amountBuffer,
        wallet,
        token,
        wallets,
        feeToken,
        ref$,
        feeWallet,
        decimalsConfig,
        decimals,
        balance,
        maxAmount,
        homeFee,
        resultAmountSend,
        feeType,
        txType,
        feeCustomAmount,
        usdRate,
        feeUsdRate,
        account,
        dataBuilder;
      console.log('changeAmountGeneric');
      send = store.current[field];
      /* Prevent call onChange twice */
      amountBuffer = store.current.send.amountBuffer;
      wallet = send.wallet;
      token = send.coin.token;
      wallets = store.current.account.wallets;
      feeToken =
        (ref$ = wallet.network.txFeeIn) != null
          ? ref$
          : (ref$ = send.coin.token) != null
          ? ref$
          : 'unknown';
      feeWallet = find(function (it) {
        var ref$;
        return ((ref$ = it.coin) != null ? ref$.token : void 8) === feeToken;
      })(wallets);
      if (wallet == null) {
        send.error = 'Balance is not loaded';
      }
      if (wallet == null) {
        return cb('Balance is not loaded');
      }
      decimalsConfig = send.network.decimals;
      decimals = amountSend.toString().split('.')[1];
      if (decimals != null && decimals.length > decimalsConfig) {
        send.amountSend = roundNumber(send.amountSend, {
          decimals: decimalsConfig,
        });
        amountSend = send.amountSend;
      }
      if (amountSend != null) {
        balance = +wallet.balance;
        maxAmount = Math.max(1e10, balance);
        if (+amountSend > maxAmount) {
          amountSend = maxAmount;
        }
      }
      /* Update home bridge fee */
      homeFee = (function () {
        switch (false) {
          case store.current.send.feeMode !== 'fixed':
            return div(store.current.send.homeFeePercent, Math.pow(10, 18));
          default:
            return times(
              store.current.send.amountSend,
              div(store.current.send.homeFeePercent, 100)
            );
        }
      })();
      store.current.send.homeFee = homeFee;
      store.current.send.homeFeeUsd = times(homeFee, wallet.usdRate);
      resultAmountSend = amountSend != null ? amountSend : 0;
      (ref$ = store.current.send),
        (feeType = ref$.feeType),
        (txType = ref$.txType),
        (feeCustomAmount = ref$.feeCustomAmount);
      usdRate =
        (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
      feeUsdRate =
        (ref$ = feeWallet != null ? feeWallet.usdRate : void 8) != null
          ? ref$
          : 0;
      account = {
        address: wallet.address,
        privateKey: wallet.privateKey,
        balance: wallet.balance,
      };
      send.amountSend = amountSend != null ? amountSend : '';
      send.value = times(resultAmountSend, Math.pow(10, send.network.decimals));
      send.amountObtain = resultAmountSend;
      send.amountObtainUsd = times(send.amountObtain, usdRate);
      send.amountSendUsd = calcUsd(store, amountSend);
      send.amountSendEur = calcEur(store, amountSend);
      dataBuilder = contractData({
        store: store,
      });
      return dataBuilder.formContractData(function (err) {
        var sendTo, query;
        sendTo = (function () {
          switch (false) {
            case store.current.send.isSwap !== true:
              return store.current.send.contractAddress;
            case store.current.send.to.trim().length !== 0:
              return store.current.send.wallet.address;
            default:
              return store.current.send.to;
          }
        })();
        query = {
          store: store,
          token: token,
          to: sendTo,
          data: send.data,
          network: send.network,
          amount: resultAmountSend,
          feeType: feeType,
          txType: txType,
          account: account,
          swap: send.swap,
          gasPrice: send.gasPrice,
        };
        return calcFeeBeforeSend(
          {
            store: store,
            query: query,
            fast: fast,
          },
          function (err, result) {
            console.log('calcFeeBeforeSend', result);
            var calcedFee, gasPrice, gasEstimate, txFee, amountToCharge;
            if (err != null) {
              console.error(err);
            }
            if (err != null) {
              send.error = err;
            }
            if (err != null) {
              return (send.amountSendFee = 0);
            }
            if (err != null) {
              return cb(err);
            }
            console.log('result HERE', result);
            if (result != null) {
              (calcedFee = result.calcedFee),
                (gasPrice = result.gasPrice),
                (gasEstimate = result.gasEstimate);
              if (send.gasPriceType !== 'custom') {
                send.gasPriceAuto = gasPrice;
              }
            }
            send.gasEstimate = gasEstimate;
            txFee = (function () {
              var ref$, ref1$;
              switch (false) {
                case feeType !== 'custom':
                  return send.amountSendFee;
                case result === null || isNaN(result):
                  return result;
                case (result != null ? result.calcedFee : void 8) == null:
                  console.log('result.calcedFee');
                  return result.calcedFee;
                case ((ref$ = send.network) != null
                  ? ref$.txFeeOptions
                  : void 8) == null:
                  return (ref1$ = send.network.txFeeOptions[feeType]) != null
                    ? ref1$
                    : send.network.txFee;
                default:
                  return send.network.txFee;
              }
            })();
            console.log('txFee', txFee);
            send.amountSendFee = txFee;
            send.amountSendFeeOptions[feeType] = txFee;
            send.amountCharged = (function () {
              switch (false) {
                case wallet.network.txFeeIn == null:
                  return send.amountSend;
                case (resultAmountSend != null ? resultAmountSend : '')
                  .length !== 0:
                  return txFee;
                case resultAmountSend !== '0':
                  return txFee;
                case resultAmountSend !== 0:
                  return txFee;
                case feeToken === token:
                  return resultAmountSend;
                default:
                  return plus(resultAmountSend, txFee);
              }
            })();
            send.amountChargedUsd = times(send.amountCharged, usdRate);
            send.amountSendFeeUsd = times(txFee, feeUsdRate);
            amountToCharge = (function () {
              switch (false) {
                case feeToken !== token:
                  return minus(
                    minus(wallet.balance, resultAmountSend),
                    send.amountSendFee
                  );
                default:
                  return minus(wallet.balance, resultAmountSend);
              }
            })();
            send.error = (function () {
              switch (false) {
                case wallet.balance !== '...':
                  return 'Balance is not yet loaded';
                case !(parseFloat(amountToCharge) < 0):
                  return 'Not Enough Funds';
                case !(
                  +send.amountCharged > 0 &&
                  store.current.send.feeMode === 'fixed' &&
                  +send.amountCharged < +store.current.send.homeFeePercent
                ):
                  return (
                    'Amount ' +
                    send.amountCharged +
                    ' is less than bridge fee (' +
                    store.current.send.homeFeePercent +
                    ')'
                  );
                default:
                  return '';
              }
            })();
            return cb(null);
          }
        );
      });
    };
  };
  out$.changeAmountSend = changeAmountSend = function (
    store,
    amountSend,
    fast,
    cb
  ) {
    var send,
      wallet,
      token,
      wallets,
      feeToken,
      ref$,
      feeWallet,
      decimalsConfig,
      decimals,
      resultAmountSend,
      balance,
      maxAmount,
      feeType,
      txType,
      feeCustomAmount,
      usdRate,
      feeUsdRate,
      account,
      dataBuilder;
    send = store.current['send'];
    wallet = send.wallet;
    token = send.coin.token;
    wallets = store.current.account.wallets;
    feeToken =
      (ref$ = wallet.network.txFeeIn) != null
        ? ref$
        : (ref$ = send.coin.token) != null
        ? ref$
        : 'unknown';
    feeWallet = find(function (it) {
      var ref$;
      return ((ref$ = it.coin) != null ? ref$.token : void 8) === feeToken;
    })(wallets);
    if (wallet == null) {
      send.error = 'Balance is not loaded';
    }
    if (wallet == null) {
      return cb('Balance is not loaded');
    }
    decimalsConfig = send.network.decimals;
    decimals = amountSend.toString().split('.')[1];
    resultAmountSend = amountSend != null ? amountSend : 0;
    if (decimals != null && decimals.length > decimalsConfig) {
      send.amountSend = roundNumber(resultAmountSend, {
        decimals: decimalsConfig,
      });
      amountSend = send.amountSend;
    }
    if (amountSend != null) {
      balance = +wallet.balance;
      maxAmount = Math.max(1e10, balance);
      if (+amountSend > maxAmount) {
        amountSend = maxAmount;
      }
    }
    send.amountSend = amountSend;
    (ref$ = store.current.send),
      (feeType = ref$.feeType),
      (txType = ref$.txType),
      (feeCustomAmount = ref$.feeCustomAmount);
    usdRate =
      (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
    feeUsdRate =
      (ref$ = feeWallet != null ? feeWallet.usdRate : void 8) != null
        ? ref$
        : 0;
    account = {
      address: wallet.address,
      privateKey: wallet.privateKey,
      balance: wallet.balance,
    };
    send.value = times(resultAmountSend, Math.pow(10, send.network.decimals));
    send.amountObtain = resultAmountSend;
    send.amountObtainUsd = times(send.amountObtain, usdRate);
    dataBuilder = contractData({
      store: store,
    });
    return dataBuilder.formContractData(function (err) {
      var sendTo, query;
      sendTo = (function () {
        switch (false) {
          case store.current.send.isSwap !== true:
            return store.current.send.contractAddress;
          case store.current.send.to.trim().length !== 0:
            return store.current.send.wallet.address;
          default:
            return store.current.send.to;
        }
      })();
      query = {
        store: store,
        token: token,
        to: sendTo,
        data: send.data,
        network: send.network,
        amount: resultAmountSend,
        feeType: feeType,
        txType: txType,
        account: account,
        swap: send.swap,
        gasPrice: send.gasPrice,
      };
      return calcFeeBeforeSend(
        {
          store: store,
          query: query,
          fast: fast,
        },
        function (err, result) {
          var calcedFee,
            gasPrice,
            gasEstimate,
            txFee,
            txFeeIn,
            ref$,
            minusFee,
            homeFee,
            resultAmountSend;
          if (err != null) {
            send.error = err;
          }
          if (err != null) {
            return cb(err);
          }
          if (result != null) {
            (calcedFee = result.calcedFee),
              (gasPrice = result.gasPrice),
              (gasEstimate = result.gasEstimate);
            if (send.gasPriceType !== 'custom') {
              send.gasPriceAuto = gasPrice;
            }
          }
          send.gasEstimate = gasEstimate;
          txFee = (function () {
            var ref$, ref1$;
            switch (false) {
              case feeType !== 'custom':
                return send.amountSendFee;
              case (result != null ? result.calcedFee : void 8) == null:
                return result.calcedFee;
              case ((ref$ = send.network) != null
                ? ref$.txFeeOptions
                : void 8) == null:
                return (ref1$ = send.network.txFeeOptions[feeType]) != null
                  ? ref1$
                  : send.network.txFee;
              default:
                return send.network.txFee;
            }
          })();
          /* If this is ERC20 Token (not Coin) then result send amount shoud not be minus fee */
          txFeeIn =
            wallet != null
              ? (ref$ = wallet.network) != null
                ? ref$.txFeeIn
                : void 8
              : void 8;
          minusFee = (function () {
            var ref$;
            switch (false) {
              case !(
                txFeeIn != null &&
                txFeeIn !==
                  (wallet != null
                    ? (ref$ = wallet.coin) != null
                      ? ref$.token
                      : void 8
                    : void 8)
              ):
                return 0;
              default:
                return txFee;
            }
          })();
          /* Update home bridge fee */
          homeFee = (function () {
            switch (false) {
              case store.current.send.feeMode !== 'fixed':
                return div(store.current.send.homeFeePercent, Math.pow(10, 18));
              default:
                return times(
                  store.current.send.amountSend,
                  div(store.current.send.homeFeePercent, 100)
                );
            }
          })();
          store.current.send.homeFee = homeFee;
          store.current.send.homeFeeUsd = times(homeFee, wallet.usdRate);
          resultAmountSend =
            +amountSend > +txFee
              ? minus(amountSend, txFee)
              : amountSend != null
              ? amountSend
              : 0;
          if (+amountSend > +txFee) {
            send.amountSend = minus(amountSend, minusFee);
          }
          send.amountSendUsd = calcUsd(store, send.amountSend);
          send.amountSendEur = calcEur(store, send.amountSend);
          send.amountSendFee = txFee;
          send.amountSendFeeOptions[feeType] = txFee;
          send.amountCharged = (function () {
            switch (false) {
              case wallet.network.txFeeIn == null:
                return send.amountSend;
              case (resultAmountSend != null ? resultAmountSend : '').length !==
                0:
                return txFee;
              case resultAmountSend !== '0':
                return txFee;
              case resultAmountSend !== 0:
                return txFee;
              default:
                return plus(resultAmountSend, txFee);
            }
          })();
          send.amountChargedUsd = times(send.amountCharged, usdRate);
          send.amountSendFeeUsd = times(txFee, feeUsdRate);
          send.error = (function () {
            switch (false) {
              case wallet.balance !== '...':
                return 'Balance is not yet loaded';
              case !(
                +send.amountCharged > 0 &&
                store.current.send.feeMode === 'fixed' &&
                +send.amountCharged < +store.current.send.homeFeePercent
              ):
                return (
                  'Amount ' +
                  send.amountCharged +
                  ' is less than bridge fee (' +
                  store.current.send.homeFeePercent +
                  ')'
                );
              case !(
                parseFloat(
                  minus(
                    minus(wallet.balance, resultAmountSend),
                    send.amountSendFee
                  )
                ) < 0
              ):
                return 'Not Enough Funds';
              default:
                return '';
            }
          })();
          return cb(null);
        }
      );
    });
  };
  out$.changeAmountCalcFiat = changeAmountCalcFiat = function (
    store,
    amountSend,
    fast,
    cb
  ) {
    var send,
      wallet,
      token,
      wallets,
      feeToken,
      ref$,
      feeWallet,
      decimalsConfig,
      balance,
      decimals,
      resultAmountSend,
      feeType,
      txType,
      feeCustomAmount,
      usdRate,
      feeUsdRate,
      account,
      dataBuilder;
    send = store.current['send'];
    wallet = send.wallet;
    token = send.coin.token;
    wallets = store.current.account.wallets;
    feeToken =
      (ref$ = wallet.network.txFeeIn) != null
        ? ref$
        : (ref$ = send.coin.token) != null
        ? ref$
        : 'unknown';
    feeWallet = find(function (it) {
      var ref$;
      return ((ref$ = it.coin) != null ? ref$.token : void 8) === feeToken;
    })(wallets);
    if (wallet == null) {
      send.error = 'Balance is not loaded';
    }
    if (wallet == null) {
      return cb('Balance is not loaded');
    }
    decimalsConfig = send.network.decimals;
    if (amountSend != null) {
      balance = wallet.balance;
      decimals = amountSend.toString().split('.')[1];
      if (decimals != null && decimals.length > decimalsConfig) {
        amountSend = roundNumber(amountSend, {
          decimals: decimalsConfig,
        });
      }
    }
    resultAmountSend = amountSend != null ? amountSend : 0;
    (ref$ = store.current.send),
      (feeType = ref$.feeType),
      (txType = ref$.txType),
      (feeCustomAmount = ref$.feeCustomAmount);
    usdRate =
      (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
    feeUsdRate =
      (ref$ = feeWallet != null ? feeWallet.usdRate : void 8) != null
        ? ref$
        : 0;
    account = {
      address: wallet.address,
      privateKey: wallet.privateKey,
      balance: wallet.balance,
    };
    send.amountSend = amountSend != null ? amountSend : '';
    send.amountSend = amountSend != null ? amountSend : '';
    send.value = times(resultAmountSend, Math.pow(10, send.network.decimals));
    send.amountObtain = resultAmountSend;
    send.amountObtainUsd = times(send.amountObtain, usdRate);
    dataBuilder = contractData({
      store: store,
    });
    return dataBuilder.formContractData(function (err) {
      var sendTo, query;
      sendTo = (function () {
        switch (false) {
          case store.current.send.isSwap !== true:
            return store.current.send.contractAddress;
          case store.current.send.to.trim().length !== 0:
            return store.current.send.wallet.address;
          default:
            return store.current.send.to;
        }
      })();
      query = {
        store: store,
        token: token,
        to: sendTo,
        data: send.data,
        network: send.network,
        amount: resultAmountSend,
        feeType: feeType,
        txType: txType,
        account: account,
        swap: send.swap,
        gasPrice: send.gasPrice,
      };
      return calcFeeBeforeSend(
        {
          store: store,
          query: query,
          fast: fast,
        },
        function (err, result) {
          var calcedFee, gasPrice, gasEstimate, txFee;
          if (err != null) {
            send.error = err;
          }
          if (err != null) {
            return cb(err);
          }
          if (result != null) {
            (calcedFee = result.calcedFee),
              (gasPrice = result.gasPrice),
              (gasEstimate = result.gasEstimate);
            if (send.gasPriceType !== 'custom') {
              send.gasPriceAuto = gasPrice;
            }
          }
          send.gasEstimate = gasEstimate;
          txFee = (function () {
            var ref$, ref1$;
            switch (false) {
              case feeType !== 'custom':
                return send.amountSendFee;
              case (result != null ? result.calcedFee : void 8) == null:
                console.log('cancledFee', result.calcedFee);
                return result.calcedFee;
              case ((ref$ = send.network) != null
                ? ref$.txFeeOptions
                : void 8) == null:
                return (ref1$ = send.network.txFeeOptions[feeType]) != null
                  ? ref1$
                  : send.network.txFee;
              default:
                return send.network.txFee;
            }
          })();
          console.log('txFee', txFee);
          send.amountSendFee = txFee;
          send.amountSendFeeOptions[feeType] = txFee;
          send.amountCharged = (function () {
            switch (false) {
              case wallet.network.txFeeIn == null:
                return send.amountSend;
              case (resultAmountSend != null ? resultAmountSend : '').length !==
                0:
                return txFee;
              case resultAmountSend !== '0':
                return txFee;
              case resultAmountSend !== 0:
                return txFee;
              default:
                return plus(resultAmountSend, txFee);
            }
          })();
          send.amountChargedUsd = times(send.amountCharged, usdRate);
          send.amountSendFeeUsd = times(txFee, feeUsdRate);
          send.error = (function () {
            switch (false) {
              case wallet.balance !== '...':
                return 'Balance is not yet loaded';
              case !(
                +send.amountCharged > 0 &&
                store.current.send.feeMode === 'fixed' &&
                +send.amountCharged < +store.current.send.homeFeePercent
              ):
                return (
                  'Amount ' +
                  send.amountCharged +
                  ' is less than bridge fee (' +
                  store.current.send.homeFeePercent +
                  ')'
                );
              case !(parseFloat(minus(wallet.balance, resultAmountSend)) < 0):
                return 'Not Enough Funds';
              default:
                return '';
            }
          })();
          return cb(null);
        }
      );
    });
  };
  out$.changeAmountWithoutFee = changeAmountWithoutFee = function (
    store,
    amountSend,
    fast,
    cb
  ) {
    var send,
      wallet,
      token,
      wallets,
      feeToken,
      ref$,
      feeWallet,
      decimalsConfig,
      decimals,
      balance,
      maxAmount,
      resultAmountSend,
      feeType,
      txType,
      feeCustomAmount,
      usdRate,
      feeUsdRate,
      account,
      txFee;
    send = store.current['send'];
    wallet = send.wallet;
    token = send.coin.token;
    wallets = store.current.account.wallets;
    feeToken =
      (ref$ = wallet.network.txFeeIn) != null
        ? ref$
        : (ref$ = send.coin.token) != null
        ? ref$
        : 'unknown';
    feeWallet = find(function (it) {
      var ref$;
      return ((ref$ = it.coin) != null ? ref$.token : void 8) === feeToken;
    })(wallets);
    if (wallet == null) {
      send.error = 'Balance is not loaded';
    }
    if (wallet == null) {
      return cb('Balance is not loaded');
    }
    decimalsConfig = send.network.decimals;
    decimals = amountSend.toString().split('.')[1];
    if (decimals != null && decimals.length > decimalsConfig) {
      send.amountSend = roundNumber(send.amountSend, {
        decimals: decimalsConfig,
      });
    }
    if (amountSend != null) {
      balance = +wallet.balance;
      maxAmount = Math.max(1e10, balance);
      if (+amountSend > maxAmount) {
        amountSend = maxAmount;
      }
    }
    resultAmountSend = amountSend != null ? amountSend : 0;
    (ref$ = store.current.send),
      (feeType = ref$.feeType),
      (txType = ref$.txType),
      (feeCustomAmount = ref$.feeCustomAmount);
    usdRate =
      (ref$ = wallet != null ? wallet.usdRate : void 8) != null ? ref$ : 0;
    feeUsdRate =
      (ref$ = feeWallet != null ? feeWallet.usdRate : void 8) != null
        ? ref$
        : 0;
    account = {
      address: wallet.address,
      privateKey: wallet.privateKey,
    };
    send.amountSend = amountSend != null ? amountSend : '';
    send.value = times(resultAmountSend, Math.pow(10, send.network.decimals));
    send.amountObtain = resultAmountSend;
    send.amountObtainUsd = times(send.amountObtain, usdRate);
    send.amountSendUsd = calcUsd(store, amountSend);
    send.amountSendEur = calcEur(store, amountSend);
    txFee = (function () {
      var ref$, ref1$;
      switch (false) {
        case feeType !== 'custom':
          return send.amountSendFee;
        case send.amountSendFee == null:
          return send.amountSendFee;
        case ((ref$ = send.network) != null ? ref$.txFeeOptions : void 8) ==
          null:
          return (ref1$ = send.network.txFeeOptions[feeType]) != null
            ? ref1$
            : send.network.txFee;
        default:
          return send.network.txFee;
      }
    })();
    send.amountSendFee = txFee;
    send.amountSendFeeOptions[feeType] = txFee;
    send.amountCharged = (function () {
      switch (false) {
        case wallet.network.txFeeIn == null:
          return send.amountSend;
        case (resultAmountSend != null ? resultAmountSend : '').length !== 0:
          return txFee;
        case resultAmountSend !== '0':
          return txFee;
        case resultAmountSend !== 0:
          return txFee;
        default:
          return plus(resultAmountSend, txFee);
      }
    })();
    send.amountChargedUsd = times(send.amountCharged, usdRate);
    send.amountSendFeeUsd = times(txFee, feeUsdRate);
    send.error = (function () {
      switch (false) {
        case wallet.balance !== '...':
          return 'Balance is not yet loaded';
        case !(
          +send.amountCharged > 0 &&
          store.current.send.feeMode === 'fixed' &&
          +send.amountCharged < +store.current.send.homeFeePercent
        ):
          return (
            'Amount ' +
            send.amountCharged +
            ' is less than bridge fee (' +
            store.current.send.homeFeePercent +
            ')'
          );
        case !(
          parseFloat(
            minus(minus(wallet.balance, resultAmountSend), send.amountSendFee)
          ) < 0
        ):
          return 'Not Enough Funds';
        default:
          return '';
      }
    })();
    return cb(null);
  };
  out$.changeAmount = changeAmount = changeAmountGeneric('send');
  out$.changeAmountInvoice = changeAmountInvoice =
    changeAmountGeneric('invoice');
}.call(this));
