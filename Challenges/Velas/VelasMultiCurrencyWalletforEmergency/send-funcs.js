// Generated by LiveScript 1.6.0
(function () {
  var toJS,
    ref$,
    times,
    minus,
    div,
    plus,
    createTransaction,
    pushTx,
    getTransactionInfo,
    changeAmountCalcFiat,
    changeAmountSend,
    changeAmount,
    calcCryptoFromEur,
    calcCryptoFromUsd,
    changeAmountWithoutFee,
    notifyFormResult,
    getNameMask,
    resolveAddress,
    window,
    navigate,
    bignumber,
    close,
    round,
    round5,
    round5edit,
    roundNumber,
    roundHuman,
    topup,
    getPrimaryInfo,
    createPendingTx,
    rebuildHistory,
    map,
    find,
    web3,
    calcFee,
    confirm,
    getLang,
    applyTransactions,
    getTxDetails,
    BN,
    bs58,
    assert,
    velasWeb3,
    icons,
    abis,
    out$ = (typeof exports != 'undefined' && exports) || this;
  toJS = require('mobx').toJS;
  (ref$ = require('./math.ls')),
    (times = ref$.times),
    (minus = ref$.minus),
    (div = ref$.div),
    (plus = ref$.plus);
  (ref$ = require('./api.ls')),
    (createTransaction = ref$.createTransaction),
    (pushTx = ref$.pushTx),
    (getTransactionInfo = ref$.getTransactionInfo);
  (ref$ = require('./calc-amount.js')),
    (changeAmountCalcFiat = ref$.changeAmountCalcFiat),
    (changeAmountSend = ref$.changeAmountSend),
    (changeAmount = ref$.changeAmount),
    (calcCryptoFromEur = ref$.calcCryptoFromEur),
    (calcCryptoFromUsd = ref$.calcCryptoFromUsd),
    (changeAmountWithoutFee = ref$.changeAmountWithoutFee);
  notifyFormResult = require('./send-form.ls').notifyFormResult;
  getNameMask = require('./get-name-mask.ls');
  resolveAddress = require('./resolve-address.ls');
  window = require('./browser/window.ls');
  navigate = require('./navigate.ls');
  bignumber = require('bignumber.js');
  close = require('./close.ls');
  round = require('./round.ls');
  round5 = require('./round5.ls');
  round5edit = require('./round5edit.ls');
  roundNumber = require('./round-number.ls');
  roundHuman = require('./round-human.ls');
  topup = require('./topup.ls');
  getPrimaryInfo = require('./get-primary-info.ls');
  createPendingTx = require('./pending-tx.ls').createPendingTx;
  rebuildHistory = require('./transactions.ls').rebuildHistory;
  (ref$ = require('prelude-ls')), (map = ref$.map), (find = ref$.find);
  web3 = require('./web3.ls');
  calcFee = require('./api.ls').calcFee;
  confirm = require('./pages/confirmation.ls').confirm;
  getLang = require('./get-lang.ls');
  applyTransactions = require('./apply-transactions.ls');
  getTxDetails = require('./get-tx-details.ls');
  BN = require('ethereumjs-util').BN;
  bs58 = require('bs58');
  assert = require('assert');
  velasWeb3 = require('./velas/velas-web3.ls');
  icons = require('./icons.ls');
  abis = {
    Staking: require('../web3t/contracts/StakingAuRa.json').abi,
    ValidatorSet: require('../web3t/contracts/ValidatorSetAuRa.json').abi,
    BlockReward: require('../web3t/contracts/BlockRewardAuRa.json').abi,
    Development: require('../web3t/contracts/VelasDevelopment.json').abi,
    Resolver: require('../web3t/contracts/LockupResolver.json').abi,
    Timelock: require('../web3t/contracts/LockupTimelock.json').abi,
    EvmToNativeBridge: require('../web3t/contracts/EvmToNativeBridge.json').abi,
    HomeBridgeNativeToErc:
      require('../web3t/contracts/HomeBridgeNativeToErc.json').abi,
    ForeignBridgeNativeToErc:
      require('../web3t/contracts/ForeignBridgeNativeToErc.json').abi,
    ERC20BridgeToken: require('../web3t/contracts/ERC20BridgeToken.json').abi,
    ERC677BridgeToken: require('../web3t/contracts/ERC20BridgeToken.json').abi,
    HomeERC677Bridge: require('../web3t/contracts/HomeBridgeNativeToErc.json')
      .abi,
    ForeignBridgeErcToErc:
      require('../web3t/contracts/ForeignBridgeErcToErc.json').abi,
  };
  const commonProvider = require('../web3t/providers/common/provider');

  const MAX_WAITING_RESPONE_TIME = 1500;

  const ABI = [
    {
      constant: true,
      inputs: [],
      name: 'getHomeFee',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'getForeignFee',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'dailyLimit',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'minPerTx',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'maxPerTx',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'executionDailyLimit',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'maxAvailablePerTx',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'getCurrentDay',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [
        {
          name: '_day',
          type: 'uint256',
        },
      ],
      name: 'totalSpentPerDay',
      outputs: [
        {
          name: '',
          type: 'uint256',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
    {
      constant: true,
      inputs: [],
      name: 'feeManagerContract',
      outputs: [
        {
          name: '',
          type: 'address',
        },
      ],
      payable: false,
      stateMutability: 'view',
      type: 'function',
    },
  ];

  function importAll$(obj, src) {
    for (var key in src) obj[key] = src[key];
    return obj;
  }

  /**
   * Recursively makes getHomeFee request untill find available web3Provider.
   */
  const getHomeFeeWithAvaliableWeb3Provider = (
    { web3Providers, wallet, ref2$, ref3$, addr },
    cb
  ) => {
    const [web3Provider, ...extraWeb3Providers] = web3Providers;
    if (!web3Provider) {
      return cb('[getHomeFeeWithAvaliableWeb3Provider] err: No web3Provider!');
    }

    const walletWithChangedWeb3Providers = {
      ...wallet,
      network: {
        ...wallet.network,
        api: { ...wallet.network.api, web3Provider, extraWeb3Providers },
      },
    };
    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        wallet != null
          ? (ref2$ = walletWithChangedWeb3Providers.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8
      )
    );
    web3.eth.providerUrl =
      walletWithChangedWeb3Providers.network.api.web3Provider;

    const contract = web3.eth.contract(ABI).at(addr);

    const beforeStartGetHomeFeeTime = performance.now();

    contract.getHomeFee((err, homeFee) => {
      if (err) {
        const isErrorCausedByUnavailableWeb3Provider =
          commonProvider.isErrorCausedByUnavailableWeb3Provider(err);
        const startGetHomeFeeTime = performance.now();
        // Slow provider 4466-6000 milliseconds on dev simulator
        // Fast 143-400 milliseconds on dev simulator
        const isSlowProvider =
          startGetHomeFeeTime - beforeStartGetHomeFeeTime >
          MAX_WAITING_RESPONE_TIME;
        const isExtraWeb3Providers = extraWeb3Providers.length !== 0;
        if (
          (isExtraWeb3Providers && isErrorCausedByUnavailableWeb3Provider) ||
          (isExtraWeb3Providers && isSlowProvider)
        ) {
          return getHomeFeeWithAvaliableWeb3Provider(
            {
              web3Providers: extraWeb3Providers,
              wallet: walletWithChangedWeb3Providers,
              ref2$,
              ref3$,
              addr,
            },
            cb
          );
        }
        homeFee = 0;
      }

      return cb(null, { homeFee, contractPrev: contract });
    });
  };

  /**
   * Recursively makes allowance request untill find available web3Provider.
   */
  const checkAllowanceWithAvailableWeb3Provider = (
    {
      web3Providers,
      wallet,
      send,
      value,
      FOREIGN_BRIDGE,
      FOREIGN_BRIDGE_TOKEN,
      sendValue,
      checkAllowedAmount,
      isSelfSend,
    },
    cb
  ) => {
    const [web3Provider, ...extraWeb3Providers] = web3Providers;
    if (!web3Provider) {
      return cb(
        '[checkAllowanceWithAvailableWeb3Provider] err: No web3Provider!'
      );
    }

    const walletWithChangedWeb3Providers = {
      ...wallet,
      network: {
        ...wallet.network,
        api: { ...wallet.network.api, web3Provider, extraWeb3Providers },
      },
    };

    const web3 = new Web3(
      new Web3.providers.HttpProvider(
        walletWithChangedWeb3Providers.network.api.web3Provider
      )
    );
    web3.eth.providerUrl =
      walletWithChangedWeb3Providers.network.api.web3Provider;

    let contract = web3.eth
      .contract(abis.ForeignBridgeErcToErc)
      .at(FOREIGN_BRIDGE_TOKEN);
    const formattedValue = times(value, Math.pow(10, 18));

    /* Check for allowed amount for contract */
    contract.allowance(
      walletWithChangedWeb3Providers.address,
      FOREIGN_BRIDGE,
      function (err, allowedRaw) {
        if (err) {
          const isExtraWeb3Providers = extraWeb3Providers.length !== 0;
          if (isExtraWeb3Providers) {
            return checkAllowanceWithAvailableWeb3Provider(
              {
                web3Providers: extraWeb3Providers,
                wallet: walletWithChangedWeb3Providers,
                send,
                value,
                FOREIGN_BRIDGE,
                FOREIGN_BRIDGE_TOKEN,
                sendValue,
                checkAllowedAmount,
                isSelfSend,
              },
              cb
            );
          }
        }
        const allowed = div(allowedRaw, Math.pow(10, 0));
        contract = web3.eth
          .contract(abis.ForeignBridgeErcToErc)
          .at(FOREIGN_BRIDGE);
        contract.minPerTx(function (err, minPerTxRaw) {
          const minPerTx = div(minPerTxRaw, Math.pow(10, 18));
          if (+sendValue < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' BUSD');
          }
          contract.maxAvailablePerTx(function (err, maxPerTxRaw) {
            const maxPerTx = div(maxPerTxRaw, Math.pow(10, 18));
            if (+sendValue > +maxPerTx) {
              return cb('Max amount per transaction is ' + maxPerTx + ' BUSD');
            }
            return checkAllowedAmount(
              {
                contract,
                wallet: walletWithChangedWeb3Providers,
                amount: send.amountSend,
                allowed,
                bridge: FOREIGN_BRIDGE,
                bridgeToken: FOREIGN_BRIDGE_TOKEN,
              },
              function (err) {
                if (err != null) {
                  return cb(err);
                }
                var data, contractAddress;
                data = (function () {
                  switch (false) {
                    case isSelfSend !== true:
                      return contract.transfer.getData(
                        FOREIGN_BRIDGE,
                        formattedValue
                      );
                    default: {
                      const receiver = send.to;
                      return contract.relayTokens.getData(
                        receiver,
                        formattedValue
                      );
                    }
                  }
                })();
                contractAddress = (function () {
                  switch (false) {
                    case isSelfSend !== true:
                      return FOREIGN_BRIDGE_TOKEN;
                    default:
                      return FOREIGN_BRIDGE;
                  }
                })();

                return cb(null, { data, contractAddress });
              }
            );
          });
        });
      }
    );
  };

  /**
   * Recursively makes minPerTx request untill find available web3Provider.
   */
  const generateWeb3AndContractForMinPerTxWithAvaliableWeb3Provider = (
    { web3Providers, contractConfig },
    cb
  ) => {
    const [web3Provider, ...extraWeb3Providers] = web3Providers;
    const { abi, bridge } = contractConfig;

    const web3 = new Web3(new Web3.providers.HttpProvider(web3Provider));
    web3.eth.providerUrl = web3Provider;
    const contract = web3.eth.contract(abi).at(bridge);

    return contract.minPerTx((err, minPerTxRaw) => {
      if (err) {
        if (extraWeb3Providers.length !== 0) {
          return generateWeb3AndContractForMinPerTxWithAvaliableWeb3Provider(
            {
              web3Providers: extraWeb3Providers,
              contractConfig: {
                abi,
                bridge,
              },
            },
            cb
          );
        }
      }

      return cb(null, { minPerTxRaw, web3, contractPrev: contract });
    });
  };

  module.exports = function (store, web3t) {
    var lang,
      send,
      wallet,
      feeType,
      color,
      primaryButtonStyle,
      defaultButtonStyle,
      amountBuffer,
      currentNetwork,
      sendTx,
      walletIcon,
      performSendSafe,
      performSendUnsafe,
      checkEnough,
      sendMoney,
      sendEscrow,
      up,
      isSelfSend,
      usdc_to_usdc_velas_swap,
      usdc_velas_to_usdc_swap,
      busd_velas_to_busd_swap,
      busd_to_busd_velas_swap,
      checkAllowedAmount,
      checkTxConfirmation,
      checkApprove,
      eth_usdtUsdt_velasSwap,
      usdt_velasEth_usdtSwap,
      executeContractData,
      beforeSendAnyway,
      sendAnyway,
      toHex,
      cancel,
      recipientChange,
      getValue,
      amountChange,
      performAmountEurChange,
      performAmountUsdChange,
      amountEurChange,
      amountUsdChange,
      encodeDecode,
      showData,
      showLabel,
      whenEmpty,
      history,
      network,
      invoice,
      token,
      name,
      ref$,
      wallets,
      feeWallet,
      feeToken,
      ref1$,
      isData,
      bridgeFeeToken,
      chooseAuto,
      chooseCheap,
      chooseCustom,
      chosenCheap,
      chosenAuto,
      chosenCustom,
      fromGweiToWei,
      chooseAutoGasPrice,
      chooseCustomGasPrice,
      chosenCheapGasPrice,
      chosenAutoGasPrice,
      chosenCustomGasPrice,
      sendOptions,
      pending,
      calcAmountAndFee,
      flag,
      useMax,
      useMaxTryCatch,
      useMaxAmount,
      hasSendError,
      homeFee,
      homeFeeUsd,
      getBridgeInfo;
    if (store == null || web3t == null) {
      return null;
    }
    lang = getLang(store);
    send = store.current.send;
    (wallet = send.wallet), (feeType = send.feeType);
    if (wallet == null) {
      return null;
    }
    color = getPrimaryInfo(store).color;
    primaryButtonStyle = {
      background: color,
    };
    defaultButtonStyle = {
      color: color,
    };
    amountBuffer = send.amountBuffer;
    currentNetwork = store.current.network;
    sendTx = function (arg$, cb) {
      var to,
        wallet,
        network,
        amountSend,
        amountSendFee,
        data,
        coin,
        txType,
        gas,
        swap,
        token,
        receiver,
        ref$,
        chosenNetwork,
        referTo,
        recipient,
        $gasPrice,
        txObj;
      (to = arg$.to),
        (wallet = arg$.wallet),
        (network = toJS(arg$.network)),
        (amountSend = arg$.amountSend),
        (amountSendFee = arg$.amountSendFee),
        (data = arg$.data),
        (coin = arg$.coin),
        (txType = arg$.txType),
        (gas = arg$.gas),
        (swap = arg$.swap);
      token = send.coin.token;
      if (+amountSendFee === 0) {
        return cb('Fee amount must be more than 0');
      }
      receiver =
        (ref$ = store.current.send.contractAddress) != null ? ref$ : to;
      chosenNetwork = store.current.send.chosenNetwork;
      referTo = chosenNetwork != null ? chosenNetwork.referTo : void 8;
      recipient = (function () {
        switch (false) {
          case !(
            referTo != null &&
            referTo !== 'vlx_native' &&
            receiver.startsWith('V')
          ):
            return toEthAddress(receiver);
          case !(coin.token !== 'vlx_native' && receiver.startsWith('V')):
            return toEthAddress(receiver);
          default:
            return receiver;
        }
      })();
      $gasPrice = (function () {
        switch (false) {
          case send.gasPriceType !== 'custom':
            return times(send.gasPriceCustomAmount, Math.pow(10, 9));
          default:
            return send.gasPrice;
        }
      })();
      txObj = {
        account: {
          address: wallet.address,
          privateKey: wallet.privateKey,
          secretKey: wallet.secretKey,
        },
        recipient: recipient,
        network: toJS(network),
        token: token,
        coin: coin,
        amount: amountSend,
        amountFee: amountSendFee,
        data: data,
        gas: gas,
        gasPrice: $gasPrice,
        feeType: feeType,
        swap: swap,
      };
      return createTransaction(txObj, function (err, txData) {
        var parts;
        if (err != null) {
          return cb(err);
        }
        parts = getTxDetails(store);
        return confirm(store, parts[0], function (agree) {
          if (!agree) {
            return cb(null);
          }
          return pushTx(
            import$(
              {
                token: token,
                txType: txType,
                network: toJS(network),
              },
              txData
            ),
            function (err, tx) {
              if (err != null) {
                const hideErrorMessage = () => {
                  setTimeout(() => {
                    store.current.send.error = '';
                    store.current.send.parseError = '';
                  }, 7500);
                };
                const errorMessage = err.toString();
                if (
                  errorMessage.indexOf(
                    'Unexpected token < in JSON at position 0'
                  )
                ) {
                  store.current.send.parseError = 'Invalid response. Code 11';
                  hideErrorMessage();
                } else {
                  store.current.send.parseError = errorMessage;
                  hideErrorMessage();
                }
                return cb(err);
              }
              return createPendingTx(
                {
                  store: store,
                  token: token,
                  recipient: recipient,
                  network: network,
                  tx: tx,
                  amountSend: amountSend,
                  amountSendFee: amountSendFee,
                  to: send.to,
                  from: wallet.address,
                },
                function (err) {
                  store.forceReload = true;
                  store.forceReloadTxs = true;
                  return cb(err, tx);
                }
              );
            }
          );
        });
      });
    };
    walletIcon = (function () {
      var ref$;
      switch (false) {
        case !(
          ((ref$ = wallet.coin) != null ? ref$.custom : void 8) === true &&
          icons.customWalletIcon != null
        ):
          return icons.customWalletIcon;
        default:
          return wallet.coin.image;
      }
    })();
    performSendSafe = function (cb) {
      return resolveAddress(
        {
          store: store,
          address: send.to,
          coin: send.coin,
          network: send.network,
        },
        function (err, to) {
          var _coin, resolved;
          _coin = send.coin.token === 'vlx2' ? 'vlx' : send.coin.token;
          if (err != null && err.indexOf('Invalid checksum')) {
            err = 'Address is not valid ' + _coin + ' address';
          }
          resolved = (function () {
            switch (false) {
              case err == null:
                return send.to;
              default:
                return to;
            }
          })();
          send.to = resolved;
          if (err != null) {
            send.error = err;
          }
          if (err != null) {
            return cb(err);
          }
          return sendTx(
            import$(
              {
                wallet: wallet,
              },
              send
            ),
            cb
          );
        }
      );
    };
    performSendUnsafe = function (cb) {
      return sendTx(
        import$(
          {
            wallet: wallet,
          },
          send
        ),
        cb
      );
    };
    checkEnough = function (cb) {
      var txFeeIn, ref$, fee, amount, ref1$, err;
      txFeeIn =
        wallet != null
          ? (ref$ = wallet.network) != null
            ? ref$.txFeeIn
            : void 8
          : void 8;
      fee = (function () {
        var ref$;
        switch (false) {
          case !(
            txFeeIn == null ||
            txFeeIn !==
              (wallet != null
                ? (ref$ = wallet.coin) != null
                  ? ref$.token
                  : void 8
                : void 8)
          ):
            return 0;
          default:
            return send.amountSendFee;
        }
      })();
      try {
        amount = minus(
          minus(
            minus(wallet.balance, send.amountSend),
            (ref1$ = wallet.pendingSent) != null ? ref1$ : 0
          ),
          fee
        );
        if (+amount < 0) {
          return cb('Not Enough funds');
        }
        return cb(null);
      } catch (e$) {
        err = e$;
        return cb(err);
      }
    };
    sendMoney = function () {
      if (wallet.balance === '...') {
        return;
      }
      if (send.sending === true) {
        return;
      }
      return checkEnough(function (err) {
        var ref$;
        if (err != null) {
          console.error('[check-enough]: ' + err);
        }
        if (err != null) {
          return (send.error =
            ((ref$ = err.message) != null ? ref$ : err) + '');
        }
        send.sending = true;
        return performSendSafe(function (err, data) {
          var ref$;
          send.sending = false;
          if (err != null) {
            send.error = ((ref$ = err.message) != null ? ref$ : err) + '';
          }
          if (
            err != null &&
            (((ref$ = err.message) != null ? ref$ : err) + '').indexOf(
              'Fee amount must be more than 0'
            ) > -1
          ) {
            setTimeout(function () {
              return (send.error = '');
            }, 1000);
          }
          if (err != null) {
            return;
          }
          if (data == null) {
            return null;
          }
          notifyFormResult(send.id, null, data);
          store.current.lastTxUrl = (function () {
            switch (false) {
              case !send.network.api.linktx:
                return send.network.api.linktx.replace(':hash', data);
              case !send.network.api.url:
                return send.network.api.url + ('/tx/' + data);
            }
          })();
          if (send.network.api.cluster) {
            store.current.lastTxUrl =
              store.current.lastTxUrl + '?cluster=' + send.network.api.cluster;
          }
          navigate(store, web3t, 'sent');
          return web3t.refresh(function () {});
        });
      });
    };
    sendEscrow = function () {
      var name, amountEthers;
      name = send.to;
      return (amountEthers = send.amountSend);
    };
    up = function (str) {
      return (str != null ? str : '').trim().toUpperCase();
    };
    isSelfSend = up(wallet.address) === up(store.current.send.to);
    /* DONE! */
    /*
     * Swap from USDC to USDC VELAS
     */
    usdc_to_usdc_velas_swap = function (token, chosenNetwork, cb) {
      var web3,
        ref$,
        FOREIGN_BRIDGE,
        FOREIGN_BRIDGE_TOKEN,
        value,
        receiver,
        contract,
        allowedRaw,
        allowed,
        coin,
        gas,
        gasPrice,
        amountSend,
        amountSendFee,
        feeType,
        network,
        txType,
        ref1$,
        ref2$,
        ref3$,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx;
      if (!(token === 'usdc' && chosenNetwork.id === 'vlx_usdc')) {
        return cb(null);
      }
      web3 = velasWeb3(store);
      (ref$ = wallet.network),
        (FOREIGN_BRIDGE = ref$.FOREIGN_BRIDGE),
        (FOREIGN_BRIDGE_TOKEN = ref$.FOREIGN_BRIDGE_TOKEN);
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 6));
      receiver = send.to;
      web3 = new Web3(
        new Web3.providers.HttpProvider(wallet.network.api.web3Provider)
      );
      web3.eth.providerUrl = wallet.network.api.web3Provider;
      contract = web3.eth
        .contract(abis.ForeignBridgeErcToErc)
        .at(FOREIGN_BRIDGE_TOKEN);
      /*---*/
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 6));
      receiver = send.to;
      /* Check for allowed amount for contract */
      allowedRaw = contract.allowance(wallet.address, FOREIGN_BRIDGE);
      allowed = div(allowedRaw, Math.pow(10, wallet.network.decimals));
      (coin = send.coin),
        (gas = send.gas),
        (gasPrice = send.gasPrice),
        (amountSend = send.amountSend),
        (amountSendFee = send.amountSendFee),
        (feeType = send.feeType),
        (network = send.network),
        (txType = send.txType);
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref$ = wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        wallet != null
          ? (ref2$ = wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      contract = web3.eth
        .contract(abis.ForeignBridgeErcToErc)
        .at(FOREIGN_BRIDGE);
      minPerTxRaw = contract.minPerTx();
      minPerTx = div(minPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend < +minPerTx) {
        return cb('Min amount per transaction is ' + minPerTx + ' USDC');
      }
      maxPerTxRaw = contract.maxAvailablePerTx();
      maxPerTx = div(maxPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend > +maxPerTx) {
        return cb('Max amount per transaction is ' + maxPerTx + ' USDC');
      }
      return checkAllowedAmount(
        {
          contract: contract,
          wallet: wallet,
          amount: send.amountSend,
          allowed: allowed,
          bridge: FOREIGN_BRIDGE,
          bridgeToken: FOREIGN_BRIDGE_TOKEN,
        },
        function (err) {
          var data, contractAddress;
          if (err != null) {
            return cb(err);
          }
          data = (function () {
            switch (false) {
              case isSelfSend !== true:
                return contract.transfer.getData(FOREIGN_BRIDGE, value);
              default:
                return contract.relayTokens.getData(receiver, value);
            }
          })();
          contractAddress = (function () {
            switch (false) {
              case isSelfSend !== true:
                return FOREIGN_BRIDGE_TOKEN;
              default:
                return FOREIGN_BRIDGE;
            }
          })();
          store.current.send.contractAddress = contractAddress;
          store.current.send.data = data;
          return cb(null, data);
        }
      );
    };
    /* DONE! */
    /*
     * Swap from USDC VELAS to USDC
     */
    usdc_velas_to_usdc_swap = function (token, chosenNetwork, cb) {
      var web3,
        ref$,
        HOME_BRIDGE,
        HOME_BRIDGE_TOKEN,
        value,
        receiver,
        ref1$,
        ref2$,
        ref3$,
        contract,
        network,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx,
        err,
        data;
      if (!(token === 'vlx_usdc' && chosenNetwork.id === 'usdc')) {
        return cb(null);
      }
      web3 = velasWeb3(store);
      (ref$ = wallet.network),
        (HOME_BRIDGE = ref$.HOME_BRIDGE),
        (HOME_BRIDGE_TOKEN = ref$.HOME_BRIDGE_TOKEN);
      if (HOME_BRIDGE == null) {
        return cb('HOME_BRIDGE is not defined');
      }
      if (HOME_BRIDGE_TOKEN == null) {
        return cb('HOME_BRIDGE_TOKEN is not defined');
      }
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 6));
      receiver = send.to;
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref$ = wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        wallet != null
          ? (ref2$ = wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      contract = web3.eth.contract(abis.ERC20BridgeToken).at(HOME_BRIDGE);
      network = wallet.network;
      try {
        minPerTxRaw = contract.minPerTx();
        minPerTx = div(minPerTxRaw, Math.pow(10, 6));
        if (+send.amountSend < +minPerTx) {
          return cb('Min amount per transaction is ' + minPerTx + ' USDC');
        }
        maxPerTxRaw = contract.maxAvailablePerTx();
        maxPerTx = div(maxPerTxRaw, Math.pow(10, 6));
        if (+send.amountSend > +maxPerTx) {
          return cb('Max amount per transaction is ' + maxPerTx + ' USDC');
        }
      } catch (e$) {
        err = e$;
        if (err != null) {
          return cb(err);
        }
      }
      data = contract.transferAndCall.getData(HOME_BRIDGE, value, send.to);
      store.current.send.contractAddress = HOME_BRIDGE_TOKEN;
      store.current.send.data = data;
      return cb(null, data);
    };
    /* DONE! */
    busd_velas_to_busd_swap = function (token, chosenNetwork, cb) {
      var web3,
        ref$,
        HOME_BRIDGE,
        HOME_BRIDGE_TOKEN,
        value,
        receiver,
        ref1$,
        ref2$,
        ref3$,
        contract,
        network,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx,
        data;
      if (!(token === 'vlx_busd' && chosenNetwork.id === 'busd')) {
        return cb(null);
      }
      web3 = velasWeb3(store);
      (ref$ = wallet.network),
        (HOME_BRIDGE = ref$.HOME_BRIDGE),
        (HOME_BRIDGE_TOKEN = ref$.HOME_BRIDGE_TOKEN);
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 18));
      receiver = send.to;
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref$ = wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        wallet != null
          ? (ref2$ = wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      contract = web3.eth.contract(abis.ERC20BridgeToken).at(HOME_BRIDGE);
      network = wallet.network;
      minPerTxRaw = contract.minPerTx();
      minPerTx = div(minPerTxRaw, Math.pow(10, 18));
      if (+send.amountSend < +minPerTx) {
        return cb('Min amount per transaction is ' + minPerTx + ' BUSD');
      }
      maxPerTxRaw = contract.maxAvailablePerTx();
      maxPerTx = div(maxPerTxRaw, Math.pow(10, 18));
      if (+send.amountSend > +maxPerTx) {
        return cb('Max amount per transaction is ' + maxPerTx + ' BUSD');
      }
      data = contract.transferAndCall.getData(HOME_BRIDGE, value, send.to);
      store.current.send.contractAddress = HOME_BRIDGE_TOKEN;
      store.current.send.data = data;
      return cb(null, data);
    };
    /* DONE! */
    busd_to_busd_velas_swap = function (token, chosenNetwork, cb) {
      var wallets,
        chosenNetworkWallet,
        ref$,
        FOREIGN_BRIDGE,
        FOREIGN_BRIDGE_TOKEN,
        web3,
        contract,
        value,
        receiver,
        allowedRaw,
        allowed,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx;
      if (!(token === 'busd' && chosenNetwork.id === 'vlx_busd')) {
        return cb(null);
      }
      wallets = store.current.account.wallets;
      chosenNetworkWallet = find(function (it) {
        return it.coin.token === chosenNetwork.id;
      })(wallets);
      if (chosenNetworkWallet == null) {
        return cb(
          '[Swap error]: wallet ' + chosenNetwork.id + ' is not found!'
        );
      }
      (ref$ = wallet.network),
        (FOREIGN_BRIDGE = ref$.FOREIGN_BRIDGE),
        (FOREIGN_BRIDGE_TOKEN = ref$.FOREIGN_BRIDGE_TOKEN);
      value = store.current.send.amountSend;
      const sendValue = send.amountSend;
      /* Check for allowed amount for contract */
      const { web3Provider, extraWeb3Providers } = toJS(wallet.network.api);
      const web3Providers = commonProvider.getWeb3Providers(
        web3Provider,
        extraWeb3Providers
      );

      checkAllowanceWithAvailableWeb3Provider(
        {
          web3Providers,
          wallet,
          send,
          value,
          chosenNetworkWallet,
          FOREIGN_BRIDGE,
          FOREIGN_BRIDGE_TOKEN,
          sendValue,
          checkAllowedAmount,
          isSelfSend,
          store,
        },
        (err, result) => {
          if (err) {
            return cb(err);
          }
          const { data, contractAddress } = result;
          store.current.send.contractAddress = contractAddress;
          store.current.send.data = data;
          return cb(null, data);
        }
      );
    };
    /* Check for allowed amount for contract */
    checkAllowedAmount = function (arg$, cb) {
      var contract,
        wallet,
        amount,
        allowed,
        bridge,
        bridgeToken,
        token,
        ref$,
        ref1$;
      (contract = arg$.contract),
        (wallet = arg$.wallet),
        (amount = arg$.amount),
        (allowed = arg$.allowed),
        (bridge = arg$.bridge),
        (bridgeToken = arg$.bridgeToken);
      if (store.current.send.checkingAllowed === true) {
        return;
      }
      if (isSelfSend === true) {
        return cb(null);
      }
      if (bridge == null) {
        return cb('bridge is not defined');
      }
      if (bridgeToken == null) {
        return cb('bridgeToken is not defined');
      }
      console.log({
        allowed: allowed,
        amount: amount,
      });
      if (!new bignumber(allowed).lt(amount)) {
        return cb(null);
      }
      token = (
        (ref$ =
          wallet != null
            ? (ref1$ = wallet.coin) != null
              ? ref1$.nickname
              : void 8
            : void 8) != null
          ? ref$
          : ''
      ).toUpperCase();
      return confirm(
        store,
        'To execute this swap please approve that bridge contract can withdraw your ' +
          token +
          ' and automate payments for you.',
        function (agree) {
          var UINT_MAX_NUMBER,
            coin,
            gas,
            gasPrice,
            amountSend,
            amountSendFee,
            feeType,
            network,
            txType,
            data,
            txObj;
          if (!agree) {
            return cb('Canceled by user');
          }
          UINT_MAX_NUMBER = times(
            4294967295,
            Math.pow(10, wallet.network.decimals)
          );
          (coin = send.coin),
            (gas = send.gas),
            (gasPrice = send.gasPrice),
            (amountSend = send.amountSend),
            (amountSendFee = send.amountSendFee),
            (feeType = send.feeType),
            (network = send.network),
            (txType = send.txType);
          data = contract.approve.getData(bridge, UINT_MAX_NUMBER);
          txObj = {
            account: {
              address: wallet.address,
              privateKey: wallet.privateKey,
            },
            recipient: bridgeToken,
            network: toJS(network),
            token: token,
            coin: coin,
            amount: '0',
            amountFee: '0.0002',
            data: data,
            gas: 150000,
            gasPrice: null,
            feeType: feeType,
          };
          return createTransaction(txObj, function (err, txData) {
            if (err != null) {
              return cb(
                '[check-allowed-amount / create-transaction] err:' + err
              );
            }
            store.current.send.checkingAllowed = true;
            return pushTx(
              import$(
                {
                  token: token,
                  txType: txType,
                  network: toJS(network),
                },
                txData
              ),
              function (err, tx) {
                if (err != null) {
                  store.current.send.checkingAllowed = false;
                  return cb(err);
                }
                return checkApprove(
                  {
                    start: Date.now(),
                    token: wallet != null ? wallet.coin.token : void 8,
                    network: wallet.network,
                    tx: tx,
                  },
                  function (err, res) {
                    store.current.send.checkingAllowed = false;
                    if (err != null) {
                      return cb(err);
                    }
                    return cb(null);
                  }
                );
              }
            );
          });
        }
      );
    };
    checkTxConfirmation = function (arg$, cb) {
      var start, token, network, tx;
      (start = arg$.start),
        (token = arg$.token),
        (network = arg$.network),
        (tx = arg$.tx);
      return function () {
        if (Date.now() > start + 60000) {
          return cb(
            'Transaction approve timeout has expired. Try to repeat later.'
          );
        }
        return getTransactionInfo(
          {
            token: token,
            network: network,
            tx: tx,
          },
          function (err, moreInfo) {
            var ref$;
            if (
              (moreInfo != null ? moreInfo.status : void 8) === 'confirmed' ||
              (moreInfo != null
                ? (ref$ = moreInfo.info) != null
                  ? ref$.status
                  : void 8
                : void 8) === '0x1'
            ) {
              cb(null);
            }
            return console.log({
              err: err,
              moreInfo: moreInfo,
            });
          }
        );
      };
    };
    checkApprove = function (arg$, cb) {
      var start, token, network, tx, timerCb;
      (start = arg$.start),
        (token = arg$.token),
        (network = arg$.network),
        (tx = arg$.tx);
      timerCb = function (err, res) {
        clearInterval(checkApprove.timer);
        return cb(err, res);
      };
      return (checkApprove.timer = setInterval(
        checkTxConfirmation(
          {
            start: start,
            token: token,
            network: network,
            tx: tx,
          },
          timerCb
        ),
        1000
      ));
    };
    /*
     * Swap from USDT ETHEREUM to USDT VELAS
     */
    eth_usdtUsdt_velasSwap = function (token, chosenNetwork, cb) {
      var web3,
        ref$,
        FOREIGN_BRIDGE,
        FOREIGN_BRIDGE_TOKEN,
        value,
        receiver,
        ref1$,
        ref2$,
        ref3$,
        contract,
        allowedRaw,
        allowed,
        network,
        data,
        contractAddress,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx;
      if (!(token === 'usdt_erc20' && chosenNetwork.id === 'vlx_usdt')) {
        return cb(null);
      }
      web3 = velasWeb3(store);
      (ref$ = wallet.network),
        (FOREIGN_BRIDGE = ref$.FOREIGN_BRIDGE),
        (FOREIGN_BRIDGE_TOKEN = ref$.FOREIGN_BRIDGE_TOKEN);
      if (FOREIGN_BRIDGE == null) {
        return cb('FOREIGN_BRIDGE is not defined');
      }
      if (FOREIGN_BRIDGE_TOKEN == null) {
        return cb('FOREIGN_BRIDGE_TOKEN is not defined');
      }
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 6));
      receiver = send.to;
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref$ = wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        wallet != null
          ? (ref2$ = wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      contract = web3.eth
        .contract(abis.ForeignBridgeErcToErc)
        .at(FOREIGN_BRIDGE_TOKEN);
      allowedRaw = contract.allowance(wallet.address, FOREIGN_BRIDGE);
      allowed = div(allowedRaw, Math.pow(10, 0));
      network = wallet.network;
      contract = web3.eth
        .contract(abis.ForeignBridgeErcToErc)
        .at(FOREIGN_BRIDGE);
      data = (function () {
        switch (false) {
          case up(wallet.address) !== up(store.current.send.to):
            return contract.transfer.getData(FOREIGN_BRIDGE, value);
          default:
            return contract.relayTokens.getData(receiver, value);
        }
      })();
      contractAddress = (function () {
        switch (false) {
          case up(wallet.address) !== up(store.current.send.to):
            return FOREIGN_BRIDGE_TOKEN;
          default:
            return FOREIGN_BRIDGE;
        }
      })();
      store.current.send.contractAddress = contractAddress;
      store.current.send.data = data;
      minPerTxRaw = contract.minPerTx();
      minPerTx = div(minPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend < +minPerTx) {
        return cb('Min amount per transaction is ' + minPerTx + ' USDT');
      }
      maxPerTxRaw = contract.maxAvailablePerTx();
      maxPerTx = div(maxPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend > +maxPerTx) {
        return cb('Max amount per transaction is ' + maxPerTx + ' USDT');
      }
      /* Check for allowed amount for contract */
      return checkAllowedAmount(
        {
          contract: contract,
          wallet: wallet,
          amount: send.amountSend,
          allowed: allowed,
          bridge: FOREIGN_BRIDGE,
          bridgeToken: FOREIGN_BRIDGE_TOKEN,
        },
        function (err) {
          if (err != null) {
            return cb(err);
          }
          return cb(null, data);
        }
      );
    };
    /*
     * Swap from USDT VELAS to USDT ETHEREUM
     */
    usdt_velasEth_usdtSwap = function (token, chosenNetwork, cb) {
      var web3,
        ref$,
        HOME_BRIDGE,
        HOME_BRIDGE_TOKEN,
        value,
        receiver,
        ref1$,
        ref2$,
        ref3$,
        contract,
        network,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx,
        data;
      if (!(token === 'vlx_usdt' && chosenNetwork.id === 'usdt_erc20')) {
        return cb(null);
      }
      web3 = velasWeb3(store);
      (ref$ = wallet.network),
        (HOME_BRIDGE = ref$.HOME_BRIDGE),
        (HOME_BRIDGE_TOKEN = ref$.HOME_BRIDGE_TOKEN);
      value = store.current.send.amountSend;
      value = times(value, Math.pow(10, 6));
      receiver = send.to;
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref$ = wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        wallet != null
          ? (ref2$ = wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      contract = web3.eth.contract(abis.ERC20BridgeToken).at(HOME_BRIDGE);
      network = wallet.network;
      minPerTxRaw = contract.minPerTx();
      minPerTx = div(minPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend < +minPerTx) {
        return cb('Min amount per transaction is ' + minPerTx + ' USDT');
      }
      maxPerTxRaw = contract.maxAvailablePerTx();
      maxPerTx = div(maxPerTxRaw, Math.pow(10, 6));
      if (+send.amountSend > +maxPerTx) {
        return cb('Max amount per transaction is ' + maxPerTx + ' USDT');
      }
      data = contract.transferAndCall.getData(HOME_BRIDGE, value, send.to);
      store.current.send.contractAddress = HOME_BRIDGE_TOKEN;
      store.current.send.data = data;
      return cb(null, data);
    };
    executeContractData = function (arg$, cb) {
      var store,
        chosenNetwork,
        token,
        ref$,
        wallet,
        contractAddress,
        data,
        dummy,
        func;
      store = arg$.store;
      if (store.current.send.chosenNetwork == null) {
        return cb(null);
      }
      chosenNetwork = store.current.send.chosenNetwork;
      token = store.current.send.coin.token;
      if (
        ((ref$ = chosenNetwork.id) === 'vlx_evm' || ref$ === 'vlx2') &&
        (token === 'vlx_evm' || token === 'vlx2')
      ) {
        store.current.send.contractAddress = null;
        return cb(null);
      }
      wallet = store.current.send.wallet;
      contractAddress = store.current.send.contractAddress;
      data = '';
      send.swap = true;
      /* DONE! */
      dummy = function (a, b, cb) {
        return cb(null);
      };
      func = (function () {
        switch (false) {
          case !(token === 'usdt_erc20' && chosenNetwork.id === 'vlx_usdt'):
            /* Swap from USDT ETHEREUM to USDT VELAS  */
            return eth_usdtUsdt_velasSwap;
          case !(token === 'vlx_usdt' && chosenNetwork.id === 'usdt_erc20'):
            /* Swap from USDT VELAS to USDT ETHEREUM */
            return usdt_velasEth_usdtSwap;
          case !(token === 'busd' && chosenNetwork.id === 'vlx_busd'):
            /* Swap from BUSD to BUSD VELAS */
            return busd_to_busd_velas_swap;
          case !(token === 'vlx_busd' && chosenNetwork.id === 'busd'):
            /* Swap from BUSD VELAS to BUSD */
            return busd_velas_to_busd_swap;
          case !(token === 'usdc' && chosenNetwork.id === 'vlx_usdc'):
            /* Swap from USDC to USDC VELAS */
            return usdc_to_usdc_velas_swap;
          case !(token === 'vlx_usdc' && chosenNetwork.id === 'usdc'):
            /* Swap from USDC VELAS to USDC */
            return usdc_velas_to_usdc_swap;
          default:
            return dummy;
        }
      })();
      return func(token, chosenNetwork, function (err, data) {
        var wallets,
          chosenNetworkWallet,
          HECO_SWAP__HOME_BRIDGE,
          web3,
          ref$,
          ref1$,
          ref2$,
          ref3$,
          contract,
          receiver,
          network,
          minPerTxRaw,
          minPerTx,
          maxPerTxRaw,
          maxPerTx,
          value,
          ref4$,
          FOREIGN_BRIDGE,
          FOREIGN_BRIDGE_TOKEN,
          ref5$,
          ref6$,
          ref7$,
          ref8$,
          BSC_SWAP__HOME_BRIDGE,
          ERC20BridgeToken,
          ref9$,
          ref10$,
          ref11$,
          contractAddress,
          amountToSend,
          ref12$,
          ref13$,
          ref14$,
          ref15$,
          HOME_BRIDGE,
          ref16$,
          value2,
          sendingTo,
          referTo,
          $recipient,
          recipient,
          hex,
          ethAddress;
        if (err != null) {
          return cb(err);
        }
        /* DONE */
        /* Swap from VELAS EVM to HECO */
        if (token === 'vlx_evm' && chosenNetwork.id === 'vlx_huobi') {
          wallets = store.current.account.wallets;
          chosenNetworkWallet = find(function (it) {
            return it.coin.token === chosenNetwork.id;
          })(wallets);
          if (chosenNetworkWallet == null) {
            return cb(
              '[Swap error]: wallet ' + chosenNetwork.id + ' is not found!'
            );
          }
          HECO_SWAP__HOME_BRIDGE = wallet.network.HECO_SWAP__HOME_BRIDGE;
          web3 = new Web3(
            new Web3.providers.HttpProvider(
              wallet != null
                ? (ref$ = wallet.network) != null
                  ? (ref1$ = ref$.api) != null
                    ? ref1$.web3Provider
                    : void 8
                  : void 8
                : void 8
            )
          );
          web3.eth.providerUrl =
            wallet != null
              ? (ref2$ = wallet.network) != null
                ? (ref3$ = ref2$.api) != null
                  ? ref3$.web3Provider
                  : void 8
                : void 8
              : void 8;
          contract = web3.eth
            .contract(abis.HomeBridgeNativeToErc)
            .at(HECO_SWAP__HOME_BRIDGE);
          receiver = store.current.send.to;
          network = wallet.network;
          minPerTxRaw = contract.minPerTx();
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          maxPerTxRaw = contract.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          data = contract.relayTokens.getData(receiver);
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' VLX');
          }
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
          }
          send.data = data;
          store.current.send.contractAddress = HECO_SWAP__HOME_BRIDGE;
        }
        /* DONE! */
        /* Swap from HECO to VELAS EVM */
        if (token === 'vlx_huobi' && chosenNetwork.id === 'vlx_evm') {
          value = store.current.send.amountSend;
          value = times(value, Math.pow(10, 18));
          (ref4$ = wallet.network),
            (FOREIGN_BRIDGE = ref4$.FOREIGN_BRIDGE),
            (FOREIGN_BRIDGE_TOKEN = ref4$.FOREIGN_BRIDGE_TOKEN);
          if (FOREIGN_BRIDGE == null) {
            return cb('FOREIGN_BRIDGE is not defined');
          }
          if (FOREIGN_BRIDGE_TOKEN == null) {
            return cb('FOREIGN_BRIDGE_TOKEN is not defined');
          }
          web3 = new Web3(
            new Web3.providers.HttpProvider(
              wallet != null
                ? (ref4$ = wallet.network) != null
                  ? (ref5$ = ref4$.api) != null
                    ? ref5$.web3Provider
                    : void 8
                  : void 8
                : void 8
            )
          );
          web3.eth.providerUrl =
            wallet != null
              ? (ref6$ = wallet.network) != null
                ? (ref7$ = ref6$.api) != null
                  ? ref7$.web3Provider
                  : void 8
                : void 8
              : void 8;
          contract = web3.eth
            .contract(abis.ForeignBridgeNativeToErc)
            .at(FOREIGN_BRIDGE);
          network = wallet.network;
          /*  Get minPerTx from HomeBridge */
          minPerTxRaw = contract.minPerTx();
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          /* Get maxPerTx from HomeBridge */
          maxPerTxRaw = contract.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' VLX');
          }
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
          }
          contract = web3.eth
            .contract(abis.ForeignBridgeNativeToErc)
            .at(FOREIGN_BRIDGE_TOKEN);
          data = (function () {
            switch (false) {
              case isSelfSend !== true:
                return contract.transfer.getData(
                  FOREIGN_BRIDGE,
                  toHex(value),
                  send.to
                );
              default:
                return contract.transferAndCall.getData(
                  FOREIGN_BRIDGE,
                  value,
                  send.to
                );
            }
          })();
          send.data = data;
          send.contractAddress = FOREIGN_BRIDGE_TOKEN;
        }
        /* DONE! */
        /* Swap from VELAS EVM to HECO */
        if (token === 'vlx_evm' && chosenNetwork.id === 'bsc_vlx') {
          wallets = store.current.account.wallets;
          chosenNetworkWallet = find(function (it) {
            return it.coin.token === chosenNetwork.id;
          })(wallets);
          if (chosenNetworkWallet == null) {
            return cb(
              '[Swap error]: wallet ' + chosenNetwork.id + ' is not found!'
            );
          }
          (ref8$ = wallet.network),
            (BSC_SWAP__HOME_BRIDGE = ref8$.BSC_SWAP__HOME_BRIDGE),
            (ERC20BridgeToken = ref8$.ERC20BridgeToken);
          web3 = new Web3(
            new Web3.providers.HttpProvider(
              wallet != null
                ? (ref8$ = wallet.network) != null
                  ? (ref9$ = ref8$.api) != null
                    ? ref9$.web3Provider
                    : void 8
                  : void 8
                : void 8
            )
          );
          web3.eth.providerUrl =
            wallet != null
              ? (ref10$ = wallet.network) != null
                ? (ref11$ = ref10$.api) != null
                  ? ref11$.web3Provider
                  : void 8
                : void 8
              : void 8;
          contract = web3.eth
            .contract(abis.HomeBridgeNativeToErc)
            .at(BSC_SWAP__HOME_BRIDGE);
          receiver = store.current.send.to;
          network = wallet.network;
          minPerTxRaw = contract.minPerTx();
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          maxPerTxRaw = contract.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          data = (function () {
            switch (false) {
              case isSelfSend !== true:
                return contract.transfer.getData(BSC_SWAP__HOME_BRIDGE, value);
              default:
                return contract.relayTokens.getData(receiver);
            }
          })();
          contractAddress = (function () {
            switch (false) {
              case isSelfSend !== true:
                return ERC20BridgeToken;
              default:
                return BSC_SWAP__HOME_BRIDGE;
            }
          })();
          data = contract.relayTokens.getData(receiver);
          amountToSend = plus(send.amountSendFee, send.amountSend);
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' VLX');
          }
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
          }
          send.data = data;
          store.current.send.contractAddress = BSC_SWAP__HOME_BRIDGE;
        }
        /* Swap from BSC VELAS to VELAS EVM */
        if (token === 'bsc_vlx' && chosenNetwork.id === 'vlx_evm') {
          value = store.current.send.amountSend;
          value = times(value, Math.pow(10, 18));
          (ref12$ = wallet.network),
            (FOREIGN_BRIDGE = ref12$.FOREIGN_BRIDGE),
            (FOREIGN_BRIDGE_TOKEN = ref12$.FOREIGN_BRIDGE_TOKEN);
          network = toJS(wallet.network);
          const web3Provider = wallet?.network?.api?.web3Provider;
          let web3Providers = commonProvider.getWeb3Providers(
            web3Provider,
            toJS(wallet?.network?.api?.extraWeb3Providers)
          );
          /* Get minPerTx from HomeBridge */
          generateWeb3AndContractForMinPerTxWithAvaliableWeb3Provider(
            {
              web3Providers,
              contractConfig: {
                abi: abis.ForeignBridgeNativeToErc,
                bridge: FOREIGN_BRIDGE,
              },
            },
            function (err, { minPerTxRaw, web3, contractPrev }) {
              minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
              /* Get maxPerTx from HomeBridge */
              maxPerTxRaw = contractPrev.maxAvailablePerTx();
              maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
              if (+send.amountSend < +minPerTx) {
                return cb('Min amount per transaction is ' + minPerTx + ' VLX');
              }
              if (+send.amountSend > +maxPerTx) {
                return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
              }
              contract = web3.eth
                .contract(abis.ForeignBridgeNativeToErc)
                .at(FOREIGN_BRIDGE_TOKEN);
              data = (function () {
                switch (false) {
                  case isSelfSend !== true:
                    return contract.transfer.getData(
                      FOREIGN_BRIDGE,
                      toHex(value),
                      send.to
                    );
                  default:
                    return contract.transferAndCall.getData(
                      FOREIGN_BRIDGE,
                      value,
                      send.to
                    );
                }
              })();
              send.data = data;
              send.contractAddress = FOREIGN_BRIDGE_TOKEN;
            }
          );
        }
        /* DONE! */
        /* Swap from ETH to ETHEREUM (VELAS) */
        if (token === 'eth' && chosenNetwork.id === 'vlx_eth') {
          wallets = store.current.account.wallets;
          chosenNetworkWallet = find(function (it) {
            return it.coin.token === chosenNetwork.id;
          })(wallets);
          if (chosenNetworkWallet == null) {
            return cb(
              '[Swap error]: wallet ' + chosenNetwork.id + ' is not found!'
            );
          }
          value = store.current.send.amountSend;
          value = toHex(times(value, Math.pow(10, 18)));
          HOME_BRIDGE = wallet.network.HOME_BRIDGE;
          web3 = new Web3(
            new Web3.providers.HttpProvider(wallet.network.api.web3Provider)
          );
          web3.eth.providerUrl = wallet.network.api.web3Provider;
          contract = web3.eth
            .contract(abis.HomeBridgeNativeToErc)
            .at(HOME_BRIDGE);
          store.current.send.contractAddress = HOME_BRIDGE;
          receiver = send.to;
          minPerTxRaw = contract.minPerTx();
          network = wallet.network;
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' ETH');
          }
          maxPerTxRaw = contract.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' ETH');
          }
          data = contract.relayTokens.getData(receiver);
          send.data = data;
        }
        /* DONE! */
        /* Swap from ETHEREUM (VELAS) to ETH  */
        if (token === 'vlx_eth' && chosenNetwork.id === 'eth') {
          value = store.current.send.amountSend;
          value = times(value, Math.pow(10, 18));
          network = wallet.network;
          (ref16$ = wallet.network),
            (FOREIGN_BRIDGE = ref16$.FOREIGN_BRIDGE),
            (FOREIGN_BRIDGE_TOKEN = ref16$.FOREIGN_BRIDGE_TOKEN);
          web3 = new Web3(
            new Web3.providers.HttpProvider(wallet.network.api.web3Provider)
          );
          web3.eth.providerUrl = wallet.network.api.web3Provider;
          contract = web3.eth
            .contract(abis.ERC20BridgeToken)
            .at(FOREIGN_BRIDGE);
          try {
            minPerTxRaw = contract.minPerTx();
            minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
            if (+send.amountSend < +minPerTx) {
              return cb('Min amount per transaction is ' + minPerTx + ' ETH');
            }
            maxPerTxRaw = contract.maxAvailablePerTx();
            maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
            if (+send.amountSend > +maxPerTx) {
              return cb('Max amount per transaction is ' + maxPerTx + ' ETH');
            }
          } catch (e$) {
            err = e$;
            return cb(err);
          }
          contract = web3.eth
            .contract(abis.ERC20BridgeToken)
            .at(FOREIGN_BRIDGE_TOKEN);
          data = contract.transferAndCall.getData(
            FOREIGN_BRIDGE,
            value,
            send.to
          );
          send.data = data;
          send.contractAddress = FOREIGN_BRIDGE_TOKEN;
        }
        /* DONE */
        /* Swap from VLX ERC20 to COIN VLX */
        if (
          token === 'vlx_erc20' &&
          ((ref16$ = chosenNetwork.id) === 'vlx_evm' || ref16$ === 'vlx2')
        ) {
          value = store.current.send.amountSend;
          value2 = toHex(times(value, Math.pow(10, 18))).toString(16);
          value = times(value, Math.pow(10, 18));
          network = wallet.network;
          (ref16$ = wallet.network),
            (FOREIGN_BRIDGE = ref16$.FOREIGN_BRIDGE),
            (FOREIGN_BRIDGE_TOKEN = ref16$.FOREIGN_BRIDGE_TOKEN);
          web3 = new Web3(
            new Web3.providers.HttpProvider(wallet.network.api.web3Provider)
          );
          web3.eth.providerUrl = wallet.network.api.web3Provider;
          contract = web3.eth
            .contract(abis.ForeignBridgeNativeToErc)
            .at(FOREIGN_BRIDGE);
          /* Get minPerTx from HomeBridge */
          minPerTxRaw = contract.minPerTx();
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          /* Get maxPerTx from HomeBridge */
          maxPerTxRaw = contract.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          sendingTo = (function () {
            switch (false) {
              case !send.to.startsWith('V'):
                return toEthAddress(send.to);
              default:
                return send.to;
            }
          })();
          contract = web3.eth
            .contract(abis.ERC20BridgeToken)
            .at(FOREIGN_BRIDGE_TOKEN);
          data = contract.transferAndCall.getData(
            FOREIGN_BRIDGE,
            value,
            sendingTo
          );
          send.data = data;
          send.contractAddress = FOREIGN_BRIDGE_TOKEN;
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' VLX');
          }
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
          }
        }
        /* DONE */
        /* Swap from COIN VLX to VLX ERC20 */
        if (
          (token === 'vlx_evm' || token === 'vlx2') &&
          chosenNetwork.id === 'vlx_erc20'
        ) {
          wallets = store.current.account.wallets;
          chosenNetworkWallet = find(function (it) {
            return it.coin.token === chosenNetwork.id;
          })(wallets);
          if (chosenNetworkWallet == null) {
            return cb(
              '[Swap error]: wallet ' + chosenNetwork.id + ' is not found!'
            );
          }
          HOME_BRIDGE = wallet.network.HOME_BRIDGE;
          receiver = store.current.send.to;
          network = wallet.network;
          minPerTxRaw = web3t.velas.HomeBridgeNativeToErc.minPerTx();
          minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
          maxPerTxRaw = web3t.velas.HomeBridgeNativeToErc.maxAvailablePerTx();
          maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          data =
            web3t.velas.HomeBridgeNativeToErc.relayTokens.getData(receiver);
          if (+send.amountSend < +minPerTx) {
            return cb('Min amount per transaction is ' + minPerTx + ' VLX');
          }
          if (+send.amountSend > +maxPerTx) {
            return cb('Max amount per transaction is ' + maxPerTx + ' VLX');
          }
          send.data = data;
          store.current.send.contractAddress = HOME_BRIDGE;
        }
        /* DONE */
        /* Swap into native */
        if (chosenNetwork.id === 'vlx_native') {
          referTo = chosenNetwork != null ? chosenNetwork.referTo : void 8;
          $recipient = '';
          try {
            recipient = (function () {
              switch (false) {
                case !(referTo !== 'vlx_native' && send.to.startsWith('V')):
                  return toEthAddress(send.to);
                default:
                  return send.to;
              }
            })();
            $recipient = bs58.decode(recipient);
            hex = $recipient.toString('hex');
          } catch (e$) {
            err = e$;
            return cb('Please enter valid address');
          }
          ethAddress = '0x' + hex;
          data =
            web3t.velas.EvmToNativeBridge.transferToNative.getData(ethAddress);
          store.current.send.contractAddress =
            web3t.velas.EvmToNativeBridge.address;
        }
        send.data = data;
        return cb(null);
      });
    };
    beforeSendAnyway = function () {
      var cb;
      cb = console.log;
      return executeContractData(
        {
          store: store,
        },
        function (err) {
          var error;
          if (err != null) {
            error = err.toString();
            if (error.toLowerCase().indexOf('canceled') !== -1) {
              return;
            }
            return (store.current.send.error = error);
          }
          return sendMoney();
        }
      );
    };
    sendAnyway = function () {
      defaultAlert({
        titile: '1',
        message: '1',
      });
      return sendMoney();
    };
    toHex = function (it) {
      return new BN(it);
    };
    cancel = function (event) {
      navigate(store, web3t, 'wallets');
      return notifyFormResult(send.id, 'Cancelled by user');
    };
    recipientChange = function (event) {
      var _to, ref$;
      _to = ((ref$ = event.target.value) != null ? ref$ : '').trim();
      send.to = _to;
      resolveAddress(
        {
          store: store,
          address: _to,
          coin: send.coin,
          network: send.network,
        },
        function (err) {
          if (err != null) {
            return (send.error = err);
          }
          send.error = '';
          return amountChange(
            {
              target: {
                value: store.current.send.amountSend,
              },
            },
            function (err) {}
          );
        }
      );
    };
    getValue = function (event) {
      var value, ref$, ref1$, ref2$;
      value = (ref$ = event.target) != null ? ref$.value : void 8;
      if (!((ref1$ = event.target) != null && ref1$.value)) {
        return '0';
      }
      if (((ref2$ = event.target) != null ? ref2$.value : void 8) === '') {
        return '0';
      }
      return value;
    };
    amountChange = function (event) {
      var value;
      value = getValue(event);
      if (value == null || isNaN(value)) {
        value = '0';
      }
      return changeAmount(store, value, false, function () {
        store.current.send.feeCalculating = false;
        amountBuffer.val = (value != null ? value : '0').toString();
        return (amountBuffer.address = store.current.send.to);
      });
    };
    performAmountEurChange = function (value) {
      var toSend;
      toSend = calcCryptoFromEur(store, value);
      return changeAmount(store, toSend, false, function () {});
    };
    performAmountUsdChange = function (value) {
      var toSend;
      toSend = calcCryptoFromUsd(store, value);
      return changeAmountCalcFiat(store, toSend, false, function () {
        return (store.current.send.feeCalculating = false);
      });
    };
    amountEurChange = function (event) {
      var value;
      value = getValue(event);
      send.amountSendEur = value;
      amountEurChange.timer = clearTimeout(amountEurChange.timer);
      return (amountEurChange.timer = setTimeout(function () {
        return performAmountEurChange(value);
      }, 500));
    };
    amountUsdChange = function (event) {
      var value, wallets, token, wallet, balance, usdRate;
      value = getValue(event);
      value = value != null ? value : 0;
      /* Prevent call onChange twice */
      if (
        (value != null ? value : '0').toString() ===
        amountBuffer.usdVal.toString()
      ) {
        return false;
      }
      wallets = store.current.account.wallets;
      token = store.current.send.coin.token;
      wallet = find(function (it) {
        return it.coin.token === token;
      })(wallets);
      (balance = wallet.balance), (usdRate = wallet.usdRate);
      send.amountSendUsd = value;
      performAmountUsdChange(value);
      return (amountBuffer.usdVal = (value != null ? value : '0').toString());
    };
    encodeDecode = function () {
      return (send.showDataMode = (function () {
        switch (false) {
          case send.showDataMode !== 'decoded':
            return 'encoded';
          default:
            return 'decoded';
        }
      })());
    };
    showData = function () {
      switch (false) {
        case send.showDataMode !== 'decoded':
          return send.decodedData;
        default:
          return send.data;
      }
    };
    showLabel = function () {
      if (send.showDataMode === 'decoded') {
        return 'encoded';
      } else {
        return 'decoded';
      }
    };
    whenEmpty = function (str, def) {
      if ((str != null ? str : '').length === 0) {
        return def;
      } else {
        return str;
      }
    };
    history = function () {
      store.current.sendMenuOpen = false;
      store.current.filter = {
        token: send.coin.token,
      };
      applyTransactions(store);
      return navigate(store, web3t, 'history');
    };
    out$.network = network = (function () {
      switch (false) {
        case store.current.network !== 'testnet':
          return ' (TESTNET) ';
        default:
          return '';
      }
    })();
    out$.invoice = invoice = function (wallet) {
      var ref$, coin, network;
      store.current.sendMenuOpen = false;
      (ref$ = store.current.send), (coin = ref$.coin), (network = ref$.network);
      importAll$(store.current.invoice, {
        coin: coin,
        wallet: wallet,
        network: network,
      });
      return navigate(store, web3t, 'invoice');
    };
    out$.token = token = send.coin.token.toUpperCase();
    out$.name = name = (ref$ = send.coin.name) != null ? ref$ : token;
    wallets = store.current.account.wallets;
    feeWallet = (function () {
      switch (false) {
        case wallet.network.txFeeIn == null:
          return find(function (it) {
            return it.coin.token === wallet.network.txFeeIn;
          })(wallets);
        default:
          return wallet;
      }
    })();
    feeWallet = feeWallet != null ? feeWallet : wallet;
    feeToken =
      (ref$ =
        feeWallet != null
          ? (ref1$ = feeWallet.coin) != null
            ? ref1$.nickname
            : void 8
          : void 8) != null
        ? ref$
        : '';
    isData = ((ref$ = send.data) != null ? ref$ : '').length > 0;
    bridgeFeeToken = wallet.network.txBridgeFeeIn;
    chooseAuto = function () {
      if (hasSendError()) {
        return;
      }
      send.feeType = 'auto';
      return changeAmount(store, send.amountSend, false, function () {});
    };
    chooseCheap = function () {
      send.feeType = 'cheap';
      return changeAmount(store, send.amountSend, false, function () {});
    };
    chooseCustom = function (amount) {
      var balance, amountSendFee, maxAmount;
      if (hasSendError()) {
        return;
      }
      balance = send.wallet.balance;
      amountSendFee = send.amountSendFee;
      send.feeType = 'custom';
      maxAmount = Math.max(1e8, balance);
      send.amountSendFee = send.feeCustomAmount = amount;
      return changeAmount(store, send.amountSend, false, function () {});
    };
    chosenCheap = send.feeType === 'cheap' ? 'chosen' : '';
    chosenAuto = send.feeType === 'auto' ? 'chosen' : '';
    chosenCustom = send.feeType === 'custom' ? 'chosen' : '';
    fromGweiToWei = function (value) {
      return times(value, Math.pow(10, 9));
    };
    /* Gas Price */
    chooseAutoGasPrice = function () {
      if (hasSendError()) {
        return;
      }
      send.gasPriceType = 'auto';
      send.gasPriceAuto = null;
      return changeAmount(store, send.amountSend, false, function () {});
    };
    chooseCustomGasPrice = function (gasPriceGwei) {
      if (hasSendError()) {
        return;
      }
      send.gasPriceType = 'custom';
      send.gasPriceCustomAmount = gasPriceGwei;
      return changeAmount(store, send.amountSend, false, function () {});
    };
    chosenCheapGasPrice = send.gasPriceType === 'cheap' ? 'chosen' : '';
    chosenAutoGasPrice = send.gasPriceType === 'auto' ? 'chosen' : '';
    chosenCustomGasPrice = send.gasPriceType === 'custom' ? 'chosen' : '';
    sendOptions = (ref$ = send.coin.txTypes) != null ? ref$ : [];
    pending = wallet.pendingSent + ' ' + token;
    calcAmountAndFee = function (amountSend, trials, cb) {
      var account;
      if (trials <= 0) {
        return cb('Cannot estimate max amount. Please try to type manually');
      }
      if (+amountSend === 0) {
        return cb('Balance is not enough to send tx');
      }
      account = {
        address: wallet.address,
        privateKey: wallet.privateKey,
      };
      return calcFee(
        {
          token: token,
          network: toJS(send.network),
          amount: amountSend,
          feeType: send.feeType,
          txType: send.txType,
          to: send.to,
          data: send.data,
          account: account,
        },
        function (err, amountSendFee) {
          if (send.feeType === 'custom') {
            amountSendFee = send.amountSendFee;
          }
          if (err == null) {
            return cb(null, {
              amountSend: amountSend,
              amountSendFee: amountSendFee,
            });
          }
          if (err != null && err !== 'Balance is not enough to send tx') {
            return cb(err);
          }
          if (amountSendFee == null) {
            return cb('Fee cannot be calculated');
          }
          return cb(null);
        }
      );
    };
    flag = false;
    useMax = function (cb) {
      var amountSend, ref$;
      amountSend = minus(
        wallet.balance,
        (ref$ = wallet.pendingSent) != null ? ref$ : 0
      );
      changeAmountSend(store, amountSend, false, function () {
        return (store.current.send.feeCalculating = false);
      });
    };
    useMaxTryCatch = function (cb) {
      var err;
      try {
        return useMax(cb);
      } catch (e$) {
        err = e$;
        store.current.send.feeCalculating = false;
        return cb(err);
      }
    };
    out$.useMaxAmount = useMaxAmount = function () {
      return useMaxTryCatch(function (err) {
        if (err != null) {
          return alert(err + '');
        }
      });
    };
    out$.hasSendError = hasSendError = function () {
      var error;
      error = store.current.send.error.toString();
      return (
        error != null &&
        error.length > 0 &&
        error.toLowerCase() !== 'not enough funds'
      );
    };
    homeFee = (function () {
      switch (false) {
        case store.current.send.feeMode !== 'fixed':
          return store.current.send.homeFeePercent;
        default:
          return times(
            store.current.send.amountSend,
            store.current.send.homeFeePercent
          );
      }
    })();
    homeFeeUsd = times(homeFee, wallet.usdRate);
    /**/
    FIXED_FEE = '0xc76cdb54';
    PERCENTAGE_FEE = '0x40c62b8f';
    /**/
    getFeeMode = function (token, feeManagerContract) {
      var mode,
        wallets,
        wallet,
        evm_wallet,
        abi,
        web3,
        ref$,
        ref1$,
        ref2$,
        ref3$,
        addr,
        contract,
        feeMode,
        err;
      mode = 'percent';
      wallets = window.store.current.account.wallets;
      wallet = wallets.find(function (it) {
        return it.coin.token === token;
      });
      evm_wallet = wallets.find(function (it) {
        return it.coin.token === 'vlx_evm';
      });
      if (wallet == null) {
        return mode;
      }
      if (feeManagerContract == null) {
        return mode;
      }
      abi = [
        {
          constant: true,
          inputs: [],
          name: 'getFeeMode',
          outputs: [
            {
              name: '',
              type: 'bytes4',
            },
          ],
          payable: false,
          stateMutability: 'view',
          type: 'function',
        },
      ];
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          evm_wallet != null
            ? (ref$ = evm_wallet.network) != null
              ? (ref1$ = ref$.api) != null
                ? ref1$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl =
        evm_wallet != null
          ? (ref2$ = evm_wallet.network) != null
            ? (ref3$ = ref2$.api) != null
              ? ref3$.web3Provider
              : void 8
            : void 8
          : void 8;
      addr = feeManagerContract;
      if (addr == null) {
        return mode;
      }
      try {
        contract = web3.eth.contract(ABI).at(addr);
        feeMode = contract.getFeeMode();
        if (feeMode !== FIXED_FEE && feeMode !== PERCENTAGE_FEE) {
          console.error('feeMode was not recognized properly ');
          return feeMode;
        }
        mode = (function () {
          switch (false) {
            case feeMode !== FIXED_FEE:
              return 'fixed';
            default:
              return 'percent';
          }
        })();
      } catch (e$) {
        err = e$;
      }
      return mode;
    };
    getBridgeInfo = function (cb) {
      var chosenNetwork,
        ref$,
        ref1$,
        token,
        ref2$,
        wallet,
        network,
        abi,
        web3,
        ref3$,
        ref4$,
        HOME_BRIDGE,
        HECO_SWAP__HOME_BRIDGE,
        BSC_SWAP__HOME_BRIDGE,
        FOREIGN_BRIDGE,
        addr,
        contract,
        homeFeePercent,
        feeMode,
        feeManagerContract,
        err,
        bridgeHomeFee,
        dailyLimit,
        currentDay,
        totalSpentPerDay,
        remainingDailyLimit,
        maxAvailablePerTx,
        minPerTxRaw,
        minPerTx,
        maxPerTxRaw,
        maxPerTx,
        wallets,
        walletTo,
        ref5$;
      chosenNetwork =
        store != null
          ? (ref$ = store.current) != null
            ? (ref1$ = ref$.send) != null
              ? ref1$.chosenNetwork
              : void 8
            : void 8
          : void 8;
      if (chosenNetwork == null) {
        return cb(null);
      }
      token = store.current.send.coin.token;
      if (
        chosenNetwork == null ||
        chosenNetwork.referTo === 'vlx_native' ||
        (token === 'vlx_native' &&
          ((ref2$ = chosenNetwork.referTo) === 'vlx' ||
            ref2$ === 'vlx2' ||
            ref2$ === 'vlx_evm')) ||
        ((token === 'vlx' || token === 'vlx_evm') &&
          ((ref2$ = chosenNetwork.referTo) === 'vlx_native' ||
            ref2$ === 'vlx2')) ||
        ((token === 'vlx2' || token === 'vlx_native' || token === 'vlx_evm') &&
          ((ref2$ = chosenNetwork.referTo) === 'vlx_native' ||
            ref2$ === 'vlx2' ||
            ref2$ === 'vlx_evm')) ||
        (token === 'vlx_native' &&
          ((ref2$ = chosenNetwork.referTo) === 'vlx' ||
            ref2$ === 'vlx2' ||
            ref2$ === 'vlx_evm'))
      ) {
        store.current.send.homeFeePercent = 0;
        return cb(null);
      }
      wallet = store.current.send.wallet;
      network = wallet.network;
      web3 = new Web3(
        new Web3.providers.HttpProvider(
          wallet != null
            ? (ref2$ = wallet.network) != null
              ? (ref3$ = ref2$.api) != null
                ? ref3$.web3Provider
                : void 8
              : void 8
            : void 8
        )
      );
      web3.eth.providerUrl = wallet.network.api.web3Provider;
      (ref4$ = wallet.network),
        (HOME_BRIDGE = ref4$.HOME_BRIDGE),
        (HECO_SWAP__HOME_BRIDGE = ref4$.HECO_SWAP__HOME_BRIDGE),
        (BSC_SWAP__HOME_BRIDGE = ref4$.BSC_SWAP__HOME_BRIDGE),
        (FOREIGN_BRIDGE = ref4$.FOREIGN_BRIDGE);
      addr = (function () {
        switch (false) {
          case !(token === 'vlx_evm' && chosenNetwork.referTo === 'vlx_huobi'):
            return HECO_SWAP__HOME_BRIDGE;
          case !(token === 'vlx_evm' && chosenNetwork.referTo === 'bsc_vlx'):
            return BSC_SWAP__HOME_BRIDGE;
          case !(token === 'usdc' && chosenNetwork.referTo === 'vlx_usdc'):
            return FOREIGN_BRIDGE;
          case !(token === 'vlx_eth' && chosenNetwork.referTo === 'eth'):
            return FOREIGN_BRIDGE;
          case !(
            token === 'usdt_erc20' && chosenNetwork.referTo === 'vlx_usdt'
          ):
            return FOREIGN_BRIDGE;
          case !(token === 'vlx_erc20' && chosenNetwork.referTo === 'vlx_evm'):
            return FOREIGN_BRIDGE;
          case !(token === 'bsc_vlx' && chosenNetwork.referTo === 'vlx_evm'):
            return FOREIGN_BRIDGE;
          case !(token === 'vlx_huobi' && chosenNetwork.referTo === 'vlx_evm'):
            return FOREIGN_BRIDGE;
          case !(token === 'busd' && chosenNetwork.referTo === 'vlx_busd'):
            return FOREIGN_BRIDGE;
          default:
            return HOME_BRIDGE;
        }
      })();
      contract = web3.eth.contract(ABI).at(addr);
      homeFeePercent = 0;
      feeMode = 'percent';
      try {
        feeManagerContract = contract.feeManagerContract();
        feeMode = getFeeMode(token, feeManagerContract);
        if (feeMode != null) {
          store.current.send.feeMode = feeMode;
        }
      } catch (e$) {
        err = e$;
      }
      homeFeePercent = 0;
      const { web3Provider, extraWeb3Providers } = network.api;
      const web3Providers = commonProvider.getWeb3Providers(
        web3Provider,
        extraWeb3Providers
      );
      getHomeFeeWithAvaliableWeb3Provider(
        {
          web3Providers,
          wallet,
          ref2$,
          ref3$,
          addr,
        },
        (e$, result) => {
          if (e$) {
            err = e$;
            store.current.send.homeFeePercent = 0;
          }
          const { contractPrev } = result;
          let { homeFee } = result;

          homeFeePercent = (function () {
            switch (false) {
              case feeMode !== 'fixed':
                return div(homeFee, Math.pow(10, network.decimals));
              default:
                return div(homeFee, Math.pow(10, network.decimals));
            }
          })();
          store.current.send.homeFeePercent = homeFeePercent;

          dailyLimit = contractPrev.dailyLimit();
          dailyLimit = div(dailyLimit, Math.pow(10, wallet.network.decimals));
          try {
            currentDay = contractPrev.getCurrentDay();
            totalSpentPerDay = contractPrev.totalSpentPerDay(currentDay);
            totalSpentPerDay = div(
              totalSpentPerDay,
              Math.pow(10, wallet.network.decimals)
            );
          } catch (e$) {
            err = e$;
            totalSpentPerDay = 0;
          }
          remainingDailyLimit = minus(dailyLimit, totalSpentPerDay);
          try {
            maxAvailablePerTx = contractPrev.maxAvailablePerTx();
            maxAvailablePerTx = div(
              maxAvailablePerTx,
              Math.pow(10, wallet.network.decimals)
            );
            store.current.send.maxAvailablePerTx = maxAvailablePerTx;
          } catch (e$) {
            err = e$;
            console.log('[maxAvailablePerTx error]: ', err);
            store.current.send.maxAvailablePerTx = 0;
          }
          try {
            minPerTxRaw = contractPrev.minPerTx();
            minPerTx = div(minPerTxRaw, Math.pow(10, network.decimals));
            maxPerTxRaw = contractPrev.maxPerTx();
            maxPerTx = div(maxPerTxRaw, Math.pow(10, network.decimals));
          } catch (e$) {
            err = e$;
            console.log('[dminPerTx/maxPerTx Error]: ', err);
          }
          store.current.send.homeDailyLimit = dailyLimit;
          importAll$(store.current.networkDetails, {
            dailyLimit: dailyLimit,
            homeFeePercent: homeFeePercent,
            minPerTx: minPerTx,
            maxPerTx: maxPerTx,
            maxAvailablePerTx: maxAvailablePerTx,
            remainingDailyLimit: remainingDailyLimit,
          });
          if (token !== 'busd' && token !== 'usdc' && token !== 'usdt_erc20') {
            return cb(null);
          }
          wallets = store.current.account.wallets;
          walletTo = find(function (it) {
            return it.coin.token === chosenNetwork.referTo;
          })(wallets);
          (ref4$ = walletTo.network),
            (HOME_BRIDGE = ref4$.HOME_BRIDGE),
            (FOREIGN_BRIDGE = ref4$.FOREIGN_BRIDGE),
            (BSC_SWAP__HOME_BRIDGE = ref4$.BSC_SWAP__HOME_BRIDGE),
            (HECO_SWAP__HOME_BRIDGE = ref4$.HECO_SWAP__HOME_BRIDGE);
          web3 = new Web3(
            new Web3.providers.HttpProvider(
              walletTo != null
                ? (ref4$ = walletTo.network) != null
                  ? (ref5$ = ref4$.api) != null
                    ? ref5$.web3Provider
                    : void 8
                  : void 8
                : void 8
            )
          );
          web3.eth.providerUrl = walletTo.network.api.web3Provider;
          addr = (function () {
            switch (false) {
              case !(
                token === 'usdt_erc20' && chosenNetwork.referTo === 'vlx_usdt'
              ):
                return HOME_BRIDGE;
              case !(token === 'usdc' && chosenNetwork.referTo === 'vlx_usdc'):
                return HOME_BRIDGE;
              case !(token === 'busd' && chosenNetwork.referTo === 'vlx_busd'):
                return HOME_BRIDGE;
            }
          })();
          contract = web3.eth.contract(ABI).at(addr);
          network = walletTo.network;
          /* Retrieve maxPerTx, minPerTx, dailyLimit, brridgeFee */
          try {
            feeManagerContract = contract.feeManagerContract();
            feeMode = getFeeMode(token, feeManagerContract);
            if (feeMode != null) {
              store.current.send.feeMode = feeMode;
            }
          } catch (e$) {}
          try {
            homeFee = contract.getForeignFee();
            homeFeePercent = (function () {
              switch (false) {
                case feeMode !== 'fixed':
                  return div(homeFee, Math.pow(10, network.decimals));
                default:
                  return div(homeFee, Math.pow(10, network.decimals));
              }
            })();
            store.current.send.homeFeePercent = homeFeePercent;
            importAll$(store.current.networkDetails, {
              homeFeePercent: homeFeePercent,
            });
          } catch (e$) {
            err = e$;
            store.current.send.homeFeePercent = 0;
            console.log('[getHomeFee Error]: ', err);
          }
          return cb(null);
        }
      );
    };
    out$.executeContractData = executeContractData;
    out$.getBridgeInfo = getBridgeInfo;
    out$.homeFee = homeFee;
    out$.homeFeeUsd = homeFeeUsd;
    out$.changeAmount = changeAmount;
    out$.send = send;
    out$.wallet = wallet;
    out$.pending = pending;
    out$.feeToken = feeToken;
    out$.bridgeFeeToken = bridgeFeeToken;
    out$.primaryButtonStyle = primaryButtonStyle;
    out$.recipientChange = recipientChange;
    out$.amountChange = amountChange;
    out$.amountUsdChange = amountUsdChange;
    out$.amountEurChange = amountEurChange;
    out$.showData = showData;
    out$.showLabel = showLabel;
    out$.topup = topup(store);
    out$.history = history;
    out$.cancel = cancel;
    out$.sendAnyway = sendAnyway;
    out$.beforeSendAnyway = beforeSendAnyway;
    out$.chooseAuto = chooseAuto;
    out$.chooseCheap = chooseCheap;
    out$.chooseCustom = chooseCustom;
    out$.chosenAuto = chosenAuto;
    out$.chosenCheap = chosenCheap;
    out$.chosenCustom = chosenCustom;
    out$.chooseAutoGasPrice = chooseAutoGasPrice;
    out$.chooseCustomGasPrice = chooseCustomGasPrice;
    out$.chosenAutoGasPrice = chosenAutoGasPrice;
    out$.chosenCheapGasPrice = chosenCheapGasPrice;
    out$.chosenCustomGasPrice = chosenCustomGasPrice;
    out$.defaultButtonStyle = defaultButtonStyle;
    out$.round5edit = round5edit;
    out$.round5 = round5;
    out$.sendOptions = sendOptions;
    out$.calcAmountAndFee = calcAmountAndFee;
    out$.isData = isData;
    out$.encodeDecode = encodeDecode;
    out$.walletIcon = walletIcon;
    return out$;
  };
  function import$(obj, src) {
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function importAll$(obj, src) {
    for (var key in src) obj[key] = src[key];
    return obj;
  }
}.call(this));
